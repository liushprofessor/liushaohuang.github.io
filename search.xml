<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小型项目领域驱动设计实践]]></title>
    <url>%2F2019%2F09%2F05%2F%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[前言 前面已经简介过领域驱动的基本概念，前文介绍的COLA框架在大型项目或者微服务架构中目测有较好的实践，但是对于一个中小项目或者小公司来说管理大量依赖包模块简直就是噩梦，或者就是项目达不到那种规模，采用分包模式也是一种浪费，但是采用领域驱动设计在本人实践过程中确实大大提升了代码质量，最主要的改善就是使开发人员不再以数据库驱动开发，而是真正的开始从业务和领域入手，这样开发出的代码往往能更好的实现面向对象，将代码划分出边界，使代码的可读性更强，代码更加健壮。本文结合现实中使用领域驱动设计时遇到的问题进行了总结，如果错误还需海涵。 项目说明 本文代码存放在 https://github.com/liushprofessor/ddd-demo 中 本文发表正在个人博客 https://liushaohuang.cn/2019/09/05/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/#more 中 关于领域驱动设计的基础概念可查看本人个人博客中关于领域驱动部分，另外这纯属个人在实践中的总结，如有错误欢迎拍砖指导。 本项目主要有3个大包分别包含3次不同的实践，实践的具体内容如全文所述 user 为第一次实践包含各种模型设计和简介 user2 正对user包下存在的一些问题做了一些优化设计，请查看全文来看具体说明 project 为了针对实际项目中出现的大聚合来做的一些设计，这个包下只建立了模型设计，其余部分如果感兴趣可以自己补充(其实就是本人偷懒) 使用方法如果你使用的是mysql数据库那么修改application.properties中的数据源即可，liquibase会自动将所需要的表建立完毕 分包 和COLA框架采用模块不同，我采用一个项目下分不同的包的模式来区分领域设计的各个模块项目结构如下 demo └─com └─liu └─demo ├─app 客户端服务代码 ├─controller 控制层代码 ├─domain 领域层 │ ├─client 领域层防腐对象 │ └─modal 领域模型 └─infrastructure 基础层 ├─repository 仓库 │ └─mapper mybatis持久包 └─serviceimpl 领域服务包 app包：客户端代码存放的地方，负责组装调用领域模型，仓库，控制事务，对应六边形架构的应用服务层 controller包: 控制层代码，我用SpringMVC实现，对应六边形架构的输入适配器 domain包: 为项目中最核心的领域模型相关类存放的地方，对应六边形架构的领域(domain)层,另外在此根目录下会存放领域服务的接口，该接口由基础设施层去实现，因为领域层是最核心的层，根据六边形架构领域层需要放在最里层，但是领域服务却有需求调用基础设施层(infrastructure)下的仓库(repository),因此在这个层中定义一个接口由infrastructure层去实现，实现依赖倒置。 client包: 我创建此包是为了反腐，为了不使领域模型外泄，有效的控制代码的边界访问而设立，举例在http协议调用中dto对象从controller层到app层，当要进入到领域层（domain）时必须将其转化成领域模型，同样数据持久化在数据库中，从数据库中直接查找到的数据对象和领域对象同样存在差异，因此需要对外创建一个过渡对象提供给基础设施层调用，也许很多人会对这些对象放在domain层有疑问，但是我认为外部数据的访问领域对象数据的范围和权限是由领域模型去控制的，因此我觉得将其放在领域(domain)包中和适合的。 modal此包主要存放实体(Entity)，值对象(VO),生成领域模型的工厂方法,领域对象验证类. infrastructure基础设施层：主要存放基础设施的地方，比如数据库持久化，调用外部服务，队列等 repository仓库，对持久化的抽象，屏蔽数据库对象生成领域对象，领域对象从创建开始就已经开始生命周期，一直到删除才结束，中间会把领域对象存储在数据库中，存储在数据库时领域对象仍然处于生命周期，因此仓库层的作用就是屏蔽持久层，让调用者觉得领域对象一直存在内存中一样. mapper 由于我使用的是mybatis，所以我创建此层建mybatis的类放在此 serviceimpl 领域服务包，同样有很多人可能会有疑问为什么我讲领域服务的实现类放在基础设施层中，这一点我上面提过，为了实现依赖导致，只要是领域服务的接口存放在领域层(domain)那么我们仍然认为领域服务属于领域层，因为接口规定了领域服务的功能和方法。 建模 在这里我们假设我们和业务方沟通需要实现这样的功能,用户可以有自己的基础信息，这些信息包括用户名，email地址，且用户可以根据用户id和密码登录系统，且用户可以单独修改登录密码，也可以修改用户信息,根据需求分析我们可以得出用户有一个唯一型标识用户id，因此我们得出用户是实体，用户名和email这两个属性对用户来说并不需要维护状态的变化，修改时候为了简单将其整个对象替换即可，因此我们将其设计成值对象VO,由于用户可以单独修改密码因此修改密码对应前端一个单独入口，所有我们将密码这个属性放在用户对象中，因此我们得到以下模型,实体对象UserE中有一个修改用户的方法，只有一个构造方法，并且可以进行密码验证和获取用户基础信息，注意这里并没有set方法，而是用了类似changePassword等方法名代替set方法，这是为了使领域模型充血，为了使模型更好的体现业务，如果使用set修改密码的话，那我们怎么和业务人员解释修改密码这个方法？难道说我set了密码？这明显无法表示出领域对象的意图，反之将其命名changePassword修改密码那么就可以很好的表示出领域模型的意图，领域方法名需要表示出领域和业务的意图。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 public class UserE &#123; private String userId; private String password; private BaseInfoVO baseInfo ; /** * 修改用户密码 */ public void changePassword(String password)&#123; if(password==null)&#123; throw new IllegalArgumentException(&quot;密码不能为空&quot;); &#125; this.password=password; &#125; public UserE(String userId, String password, BaseInfoVO baseInfo) &#123; this.userId = userId; this.password = password; this.baseInfo = baseInfo; &#125; public String getUserId() &#123; return userId; &#125; public String getPassword() &#123; return this.password; &#125; /** * 认证服务，查询传入密码是否匹配 * @param password 需要认证的密码 * @return 认证结果 */ public boolean authentication(String password) &#123; return password != null &amp;&amp; password.equals(this.password); &#125; public BaseInfoVO getBaseInfo() &#123; return baseInfo; &#125; /** * 修改用户基础信息 */ public void changeInfo(BaseInfoVO baseInfoVO)&#123; this.baseInfo=baseInfoVO; &#125;&#125; 下面是BaseInfoVO为用户的基础信息,同样我们也没有暴露set方法,由于它只是一个用户的值对象，因此并没有那么多的领域方法,至此我们的核心领域对象就已经建立完成了 123456789101112131415161718192021222324252627282930/** * @author Liush * @description 用户基础信息 * @date 2019/9/5 9:48 **/public class BaseInfoVO &#123; private String username; private String email; public BaseInfoVO(String username, String email) &#123; if(username==null)&#123; throw new IllegalArgumentException(&quot;用户名不能为空&quot;); &#125; if(email==null)&#123; throw new IllegalArgumentException(&quot;邮箱不能为空&quot;); &#125; this.username = username; this.email = email; &#125; public String getUsername() &#123; return username; &#125; public String getEmail() &#123; return email; &#125;&#125; 现在让我们考虑如何新增一个用户，创建用户对应领域模型就是创建一个用户实体(UserE),那我们如何做到将领域层的模型信息不外泄到其它地方呢?因为新增用户也属于领域（业务的一部分），举个例子我们去银行开个户也要到银行才能办理，我们不能到公安局去开银行账户，所以我们把创建用户对象放在领域层，而创建用户实体(UserE)有两种方法，一种是直接调用其构造，一种是通过工厂类来创建，但是这里又会出现一个问题，用户实体(UserE)需要一个BaseInfoVO（基础信息）来构造，但是按照领域驱动设计的理念来设计BaseInfoVO（基础信息）只能有领域在领域层中才能去创建，因为我们的通用语言是用户创建和修改了基础信息，如果我们将BaseInfoVO（基础信息）放在领域层外创建就好比一句话少了主语。我采用在领域层中使用工厂类去创建用户实体(UserE)，在工厂方法中传入一个DTO来隔离领域层外部的信息，代码如下,其创建了一个用户实体(UserE)并且使用UUID分配了一个默认的用户ID给用户，最后调用用户实体(UserE)的构造方法去创建用户实体对象，执行完这一行代码，一个用户对象就已经进入了生命周期，直到在数据库中删除或者将用户状态改成不可能用这个用户的生命周期才结束。 123456789101112131415161718192021package com.liu.demo.user.domain.modal;import com.liu.demo.user.domain.client.UserDTO;import org.springframework.stereotype.Component;import java.util.UUID;/** * @author Liush * @description 领域工厂类 * @date 2019/9/5 14:10 **/@Componentpublic class UserFactory &#123; public UserE createUser(UserDTO userDTO )&#123; BaseInfoVO baseInfoVO=new BaseInfoVO(userDTO.getUsername(),userDTO.getEmail()); return new UserE(UUID.randomUUID().toString(),userDTO.getPassword(),baseInfoVO); &#125;&#125; 持久化现在是时候考虑用户对象持久化的问题了，毕竟用户对象不能永远存留在内存中，必须在不使用对象时将其持久化到硬盘中基础设施层包infrastructure下的repository就是为了解决这个问题,它的作用是屏蔽数据库持久化的一些代码，让代码看起来更贴近领域设计一些，我们可以从仓库中根据查找条件直接还原出一个用户实体对象，对领域代码来说数据库持久化代码就好像不存在一样，下面是用户仓库代码,这里注意一下一个方法findUsersByName，这是一个查询方法，从数据库中查询出UserPO然后将其转成UserDTO，这里我们看到我们并没有走领域模型，因为查询往往为了效率特别是批量查询我们做了一部分妥协，但是这部分妥协是可以接受的，因为我们并没有执行领域动作(command)的代码，只是返回一个dto对象给前端。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.liu.demo.user.infrastructure.repository;import com.liu.demo.user.domain.client.UserDTO;import com.liu.demo.user.domain.client.UserPO;import com.liu.demo.user.domain.modal.UserE;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import com.liu.demo.user.infrastructure.repository.mapper.UserMapper;import java.util.ArrayList;import java.util.List;/** * @author Liush * @description 用户仓库 * @date 2019/9/5 11:17 **/@Repositorypublic class UserRepository &#123; @Autowired private UserMapper userMapper; @Autowired private UserRepositoryConvert userRepositoryConvert; /** * 根据用户id查找用户 */ public UserE findUser(String userId)&#123; UserPO userPO =userMapper.findUser(userId); return userRepositoryConvert.convertToUserE(userPO); &#125; /** * 添加用户 */ public void addUser(UserE user)&#123; UserPO userPO= userRepositoryConvert.convertToUserPO(user); userMapper.insertUser(userPO); &#125; /** * 修改密码 */ public void changePassword(UserE userE)&#123; userMapper.updateUserPassword(userE.getUserId(),userE.getPassword()); &#125; /** *根据用户姓名批量查询，查询可以不走领域模型 */ public List&lt;UserDTO&gt; findUsersByName(String name)&#123; List&lt;UserPO&gt; userPOs=userMapper.findUsersByName(name); List&lt;UserDTO&gt; userDTOs=new ArrayList&lt;&gt;(); if (userPOs==null)&#123; return userDTOs; &#125; userPOs.forEach(userPO-&gt;userDTOs.add(userRepositoryConvert.convertToUserDTO(userPO))); return userDTOs; &#125;&#125; 领域服务下面考虑一下这个问题，修改密码，我们在修改密码时一般都会调用远程接口，比如获取短信验证码和校验验证码，这部分放在用户实体中是不合适的，但是远程调用短信接口这部分代码又属于基础设施层的内容，但是在提供给app层调用的时候我们又不想把这部分属于业务逻辑暴露给app层，因为由app层去组装的话，那么开发app层的人员就需要知道业务的流程，他必须知道修改密码内部的流程走向（调用短信验证接口），我们想做的就是客户端开发人员只要调用一个修改密码的方法就好了，至于里面执行什么业务逻辑客户端开发人员不要操心，所以我们采用领域服务去封装修改密码的业务，由客户端开发人员去调用领域服务来屏蔽业务的细节，那么现在就会产生这样一个问题，领域层要依赖基础设施层，但是这样是有悖于六边形架构的（领域层应该放在依赖的最内部），于是我们使用依赖倒置技术，在领域层中创建一个领域服务接口，由基础设施去实现，这样就实现了基础设施层依赖领域层，但是领域层又通过接口对基础设施层领域服务可以做什么做了规定和约束。下面是领域层中的领域服务接口的定义，它提供了一个修改密码的接口 123456789101112package com.liu.demo.user.domain;/** * @author Liush * @description 用户领域服务 * @date 2019/9/5 11:07 **/public interface UserServiceI &#123; void changePassword(String userId,String password);&#125; 下面由基础设施层去实现这个接口 123456789101112131415161718192021222324252627package com.liu.demo.user.infrastructure.serviceimpl;import com.liu.demo.user.domain.UserServiceI;import com.liu.demo.user.domain.modal.UserE;import com.liu.demo.user.infrastructure.repository.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/*** @author Liush* @description User领域服务* @date 2019/9/5 11:12**/@Servicepublic class UserServiceImpl implements UserServiceI &#123; @Autowired private UserRepository userRepository; @Override public void changePassword(String userId, String password) &#123; //执行短信验证代码这边省略 UserE user =userRepository.findUser(userId); user.changePassword(password); userRepository.changePassword(user); &#125;&#125; 现在由APP层去调用修改密码 123public void changePassword(String userId,String password)&#123; userServiceI.changePassword(userId,password); &#125; 关于client二方包的思考在我最开始接触领域设计的时候这些二方包我是没有放在领域模型层里的，当时我会创建一个common包，把这些东西放在common包下，当时随着理解的深入，我认为领域驱动最核心的内容之一就是边界的划分，边界的划分就以为着可以由不同开发者去开发不同的模块(比如一个人去开发领域模型，一个人去开发app层负责组装),如果我们把写代码放在common包中，那么app层开发人员就要去建立自己的领域防腐模型(DTO,PO等)，这样一定程度上也将领域模型的内容泄露出去，与其让客户端开发人员去编写防腐代码，比如有领域层开发人员去设计这部分代码，规定领域层的输入和输出，当然还包括一些领域层和防腐层对象的装换比如示例代码中提供的UserConvert对象装换类其实现如下,这样即让领域层代码不外泄，也很好的把控客户端可以访问什么属性。 1234567891011121314151617181920package com.liu.demo.user.domain.client;import com.liu.demo.user.domain.modal.UserE;import org.springframework.stereotype.Component;/** * @author Liush * @description 转换类 * @date 2019/9/5 14:52 **/@Componentpublic class UserConvert &#123; public UserDTO convertToUserDTO(UserE userE)&#123; String username=userE.getBaseInfo().getUsername(); String email=userE.getBaseInfo().getEmail(); return new UserDTO(userE.getUserId(),userE.getPassword(),username,email); &#125;&#125; 更进一步上诉代码在一般小项目中其实也已经够用，但是眼尖的同学可能会发现存在两个问题 用户实体(UserE)中的changePassword方法是暴露给客户端的，客户端人员在APP层可以直接获取UserE对象然后绕过领域服务去修改密码，这样就不要去验证短信服务等接口了，这样做明显是不符合业务逻辑的。 实体的整体验证，上面代码用户实体(UserE)只对单个属性进行验证比如属性是否为空，但是有些实体对象存在整体验证，比如用户实体(UserE)中如果业务规定密码和邮箱都必须以数字开头怎么办？ 这一节将着手解决这个问题，这部分代码在user2包下 首先我们解决第一个问题，我们创建了一个用户抽象类,这个抽象类并没有修改密码的方法，它只暴露了客户端可以调用的代码 123456789101112131415161718192021222324252627282930313233343536package com.liu.demo.user2.domain.modal;import com.liu.demo.user2.common.DoNothingValidateHandler;import com.liu.demo.user2.common.ValidateHandlerI;/** * @author Liush * @description * @date 2019/9/5 15:27 **/public abstract class UserAbstract &#123; protected String userId; protected String password; protected BaseInfoVO baseInfo ; protected ValidateHandlerI validateHandlerI; public UserAbstract(String userId, String password, BaseInfoVO baseInfo) &#123; this.userId = userId; this.password = password; this.baseInfo = baseInfo; this.validateHandlerI=new DoNothingValidateHandler(); &#125; public abstract boolean authentication(String password); public abstract BaseInfoVO getBaseInfo(); public abstract String getUserId();&#125; 然后我们实现这个类，子类中包行了changePassword方法， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.liu.demo.user2.domain.modal;/** * @author Liush * @description 用户实体类 * @date 2019/9/5 9:47 **/public class UserE extends UserAbstract &#123; public void changePassword(String password)&#123; if(password==null)&#123; validateHandlerI.handlerError(&quot;密码不能为空&quot;,new IllegalArgumentException()); &#125; this.password=password; &#125; /** * 构造完实体后对实体进行整体验证 */ public UserE(String userId, String password, BaseInfoVO baseInfo) &#123; super(userId,password,baseInfo); new UserValidate(this).validate(); &#125; public String getUserId() &#123; return super.userId; &#125; public String getPassword() &#123; return super.password; &#125; /** * 认证服务，查询传入密码是否匹配 * @param password 需要认证的密码 * @return 认证结果 */ public boolean authentication(String password) &#123; return password != null &amp;&amp; password.equals(this.password); &#125; public BaseInfoVO getBaseInfo() &#123; return baseInfo; &#125;&#125; 现在我们在所有返回给客户端代码中的返回用户实体对象不再是UserE而是UserAbstract,如repository包下的repository对象，这样客户端就不能直接通过用户实体去修改密码，而不需通过领域服务去修改密码，而在对应的领域层代码或者基础设施代码中完成一次对象的装换即可（将UserE转成UserAbstract） 123456789101112131415161718192021222324252627282930313233343536373839package com.liu.demo.user2.infrastructure.repository;import com.liu.demo.user2.domain.client.UserPO;import com.liu.demo.user2.domain.modal.UserE;import com.liu.demo.user2.domain.modal.UserAbstract;import com.liu.demo.user2.infrastructure.repository.mapper.UserMapper2;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;/** * @author Liush * @description 用户仓库 * @date 2019/9/5 11:17 **/@Repositorypublic class UserRepository2 &#123; @Autowired private UserMapper2 userMapper; @Autowired private UserRepositoryConvert2 userRepositoryConvert; public UserAbstract findUser(String userId)&#123; UserPO userPO =userMapper.findUser(userId); return userRepositoryConvert.convertToUserE(userPO); &#125; public void addUser(UserAbstract user)&#123; UserPO userPO= userRepositoryConvert.convertToUserPO((UserE) user); userMapper.insertUser(userPO); &#125;&#125; 第二个问题解决方法这次我们定义了一个common包下面有两个基类ValidateAbstract（验证抽象类）,此类为实体整体验证的一个基类，其构成方法中需要传入一个验证处理器，这个处理器的作用是为了如过验证类整体验证失败则调用验证处理器完成错误信息处理，这样做的目的是为了可以将验证和异常处理做解耦，同样在没有参数的构造方法中体用了一个默认的验证处理器 1234567891011121314151617181920212223242526package com.liu.demo.user2.common;/** * @author Liush * @description 验证抽象类 * @date 2019/9/5 17:11 **/public abstract class ValidateAbstract &#123; protected ValidateHandlerI validateHandlerI; public ValidateAbstract(ValidateHandlerI validateHandlerI) &#123; this.validateHandlerI = validateHandlerI; &#125; public ValidateAbstract() &#123; this.validateHandlerI=ValidateHandlerFactory.doNothingValidateHandler(); &#125; public abstract void validate(); public void setValidateHandlerI(ValidateHandlerI validateHandlerI) &#123; this.validateHandlerI = validateHandlerI; &#125;&#125; 用户实体整体验证类实现 1234567891011121314151617181920212223242526272829303132333435package com.liu.demo.user2.domain.modal;import com.liu.demo.user2.common.ValidateAbstract;import com.liu.demo.user2.common.ValidateHandlerI;import org.springframework.util.StringUtils;/** * @author Liush * @description * @date 2019/9/5 17:24 **/public class UserValidate extends ValidateAbstract &#123; protected UserE userE; public UserValidate(UserE userE) &#123; super(); this.userE=userE; &#125; public UserValidate(UserE userE,ValidateHandlerI validateHandlerI) &#123; super(validateHandlerI); this.userE=userE; &#125; @Override public void validate() &#123; if(StringUtils.isEmpty(userE.getPassword()) &amp;&amp; StringUtils.isEmpty(userE.getBaseInfo().getUsername()))&#123; super.validateHandlerI.handlerError(&quot;密码和用户名不能同时为空&quot;,new RuntimeException(&quot;UserE对象整体验证失败&quot;)); &#125; &#125;&#125; 验证处理器 123456789101112package com.liu.demo.user2.common;/** * @author Liush * @description 验证错误处理器 * @date 2019/9/5 17:03 **/public interface ValidateHandlerI &#123; void handlerError(String message,Exception e);&#125; 一个默认实现的验证处理器 1234567891011121314151617181920212223package com.liu.demo.user2.common;/** * @author Liush * @description * @date 2019/9/5 17:05 **/public class DoNothingValidateHandler implements ValidateHandlerI &#123; @Override public void handlerError(String message,Exception e) &#123; System.out.println(message); if(e instanceof IllegalArgumentException)&#123; throw new IllegalArgumentException(message); &#125; if(e instanceof RuntimeException)&#123; throw new RuntimeException(message); &#125; &#125;&#125; 下面我们进行代码整合，你会发现现在再用户实体(UserE)的构造中最后多了一行代码 1234567/** * 构造完实体后对实体进行整体验证 */ public UserE(String userId, String password, BaseInfoVO baseInfo) &#123; super(userId,password,baseInfo); new UserValidate(this).validate(); &#125; 在创建用户实体(UserE)时会进行整体验证，如果不通过就抛出异常此处这两个问题解决完毕 大聚合对象在实际实践过程中遇到过一些大聚合对象，什么是大聚合对象？举个例子，现在有这么一个业务，一个软件项目，下面有成败上千的子项目，子项目都必须在父项目中创建，如果我们按照原始的设计那么代码就会变这样,这样做有什么不妥呢？比如我们以后想查看工程的名字或者修改，那么我们就必须加载整个工程的子项目，如果子项目较小，这样设计也是可以接受的，但是如果子项目有成千上万个，那么这样做有些浪费资源，而且我只是单纯的修改工程名，和子项目并没有什么关联 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.liu.demo.project.domain.modal;import java.util.Date;import java.util.List;/** * @author Liush * @description 项目旧模型 * @date 2019/9/6 10:59 **/public class ProjectEOld &#123; //项目ID private String projectId; //项目名 private String name; //项目开始日期 private Date beginDate; //子项目 private List&lt;ItemE&gt; items; public ProjectEOld(String projectId, String name, Date beginDate, List&lt;ItemE&gt; items) &#123; this.projectId = projectId; this.name = name; this.beginDate = beginDate; this.items = items; &#125; //创建子项目 public void createItem(ItemE itemE)&#123; items.add(itemE); &#125; public String getProjectId() &#123; return projectId; &#125; public String getName() &#123; return name; &#125; public Date getBeginDate() &#123; return beginDate; &#125; public List&lt;ItemE&gt; getItems() &#123; return items; &#125;&#125; 于是我们退而求次改建模型,我们现在创建了两个模型ProjectE，ItemE我们现在将这两个实体分开，ProjectE不再包含ItemE集合，在ItemE我们加入了一个属性projectId和父工程做关联，需要注意的是为了凸显领域和我们的模型是对应的我们在ProjectE中有一个createItem的方法，这个方法符合领域描述子项目是在工程中创建的，也许你们有疑问这样在视图展示方法是不是很不方便？（比如我要一次查找工程名字和工程下面所有的子项目列表），这一点我在上文已经说过，在领域设计中查询和命令是可以做分离的，查询设计可以不走领域模型. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.liu.demo.project.domain.modal;import java.util.Date;/** * @author Liush * @description 工程实体 * @date 2019/9/6 10:49 **/public class ProjectE &#123; //项目ID private String projectId; //项目名 private String name; //项目开始日期 private Date beginDate; /** *由于工程子项目属于工程，按照通用语言，工程子项目要由工程去穿件，这样保证了领域和业务模型的统一性 */ public ItemE createItem(String itemId,String name)&#123; return new ItemE(itemId,name); &#125; public ProjectE(String projectId, String name, Date beginDate) &#123; this.projectId = projectId; this.name = name; this.beginDate = beginDate; &#125; public String getProjectId() &#123; return projectId; &#125; public String getName() &#123; return name; &#125; public Date getBeginDate() &#123; return beginDate; &#125;&#125; 子项目模型 1234567891011121314151617181920212223242526272829303132333435package com.liu.demo.project.domain.modal;/** * @author Liush * @description 项目实体 * @date 2019/9/6 10:49 **/public class ItemE &#123; //工程id private String projectId; //项目实体 private String itemId; //项目名 private String name; public ItemE(String itemId, String name) &#123; this.itemId = itemId; this.name = name; &#125; public String getItemId() &#123; return itemId; &#125; public String getName() &#123; return name; &#125; public String getProjectId() &#123; return projectId; &#125;&#125; 总结使用了领域驱动设计是一个长期过程，随着业务的变化原来的模型可能不再适用，或者有一天觉得原来的模型并不合理，这些都是非常常见的现象，领域驱动设计的另一个核心就是不断重构来创造出合适的模型，没有什么所谓银弹，只有不断摸着石头过河才能构建出好的设计。最后说一点在现实生活中肯定会有一些设计和需求的矛盾，比如客户坚持要批量新增而且又要快速响应怎么办？领域设计可能会影响一部分效率，但是什么才是慢？我觉得的在合理时间内就不算是慢，比如采用过程化开发调用一个接口的响应速度是1秒，采用领域驱动设计是1.1秒那我觉得这个慢是可接受的，并不影响用户体验，但是这0.1秒换来的是代码设设计的清晰，我觉得这是一笔稳赚不赔的买卖，最后再次声明，没有所谓的银弹，世界上没有完美的事，代码一样，人生也一样，不要和甲方爸爸过不去，因为他是你的爸爸。]]></content>
      <categories>
        <category>领域驱动设计(DDD)</category>
      </categories>
      <tags>
        <tag>领域驱动设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis的缓存机制]]></title>
    <url>%2F2019%2F09%2F04%2Fmybatis%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[缓存简介 一级缓存 会话缓存 mybatis对应sqlsession，对应于一个连接 二级缓存 应用缓存，不同会话也可访问统一缓存 mybatis对应namespace 三级缓存 跨jvm 如redis mybatis缓存实践 spring事务有四个等级，在mysql inndbn内核中默认采用可重复读（两个事务同时处理一条数据 一个事务更新了，在另一个事务中读取到的仍然是旧的值），mybatis中默认开启一级缓存，如果事务等级低于可重复读 那么在两个事务同时操作一条记录中如（@Transactional( isolation =Isolation.READ_COMMITTED )），一个 事务修改另一个事务就会看见该修改，但是mybatis默认会在当前事务中从缓存中读取，需要手动调用sqlSession.clearCache(); 或者在xml select标签中加上 flushCache=”true”读取时刷新缓存，如果采用java编码方式则加上@Options(flushCache =Options.FlushCachePolicy.TRUE )注解读取时刷新mybatis缓存 在Spring中只有同一锁中读取数据才能用到一级缓存，因为同一锁中使用的是sqlSession是同一个实例对象，如果两次调用是获取不同的sqlSession,所以一级缓存无效,同样因为sqlsession不同所以update也无法对一级缓存进行刷新,另外尽量不要对mybatis返回的对象进行操作，因为返回的对象是缓存在一级缓存中的，改变返回对象一级缓存中的对象也会改变 二级缓存是基于namespqce的缓存（xml中 中的namespace）， 所有对于一张表的操作都需要放在一个namespace中，这样保证更新或者insert操作后后二级缓存可以更新，不然会导致 脏读（在另一个namespace中操作后二级缓存没更新，因为没在用一个namespace下），xml开启二级缓存在xml中添加即可， 注解版开启二级缓存在mapper接口上添加@CacheNamespace(blocking = true)]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[COLA-复杂项目领域驱动设计框架源码和架构解析]]></title>
    <url>%2F2019%2F09%2F04%2FCOLA-%E5%A4%8D%E6%9D%82%E9%A1%B9%E7%9B%AE%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E5%92%8C%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[COLA简介 可自行到github上查看md简介 https://github.com/alibaba/COLA 目录结构分析COAL提供了一个很方便的maven生成模板，按照项目说明我们生成一个web项目，打开目录我们发现如下几个子模块 父项目 └── start 项目启动模块 └── app 项目应用服务模块（可以理解为客户端程序员在此编写代码） └── client 提供给客户端程序员使用的二方包，为应用服务模块提供一下基础类 └── controller 控制层SpringMVC实现 └── domain 领域层 └── infrastructure 基础设施层，包含数据库持久化，一些其它基础设施调用代码放在此，如RPC调用，队列调用等基础设施代码其项目依赖目录如下start依赖controller，controller依赖app，app同时依赖client和infrastructure，infrastructure依赖domain start └── controller └── app ├── client ├── infrastructure └── domain从依赖中我们明显可以看到前文提到的六边形架构的影子，controller为输入端适配器，infrastructure为持久化输出适配器，而核心服务domain领域层作为软件的核心和最稳定的部分放在依赖的最底层 结合领域驱动设计分析目录结构从目录结构当中划分其实这个框架应该分为两部分，app层之下（不包括）为领域部分，这部分由对领域知识理解较好的开发人员去建模，而app层（包括）之上则为客户端代码，可以由对领域知识不那么了解的开发人员去开发，作者之所以引入client模块一方面是提供了一些二方包和接口功能客户端调用，最主要的原因是反腐，为了反腐在client包中引入DTO，为了读写分离（在领域驱动中这点很重要）又有Command和Query两个实现类，以此完成写命令和读命令的区分，因为在写命令中需要完全遵守领域模型去完成，但是在查询中往往为了响应速度等的妥协而放弃领域模型，直接从基础设施层中读取查询对象返回给前端. 应用框架方面提供了一些注解如示例中的@Command注解,其需要作用在CommandExecutorI的实现类下，这部分内容放在app层代码由客户端人员去实现，这样可以将客户端的业务逻辑放在CommandExecutorI接口规定的方法下，客户端逻辑更加清晰，一个@Command代表着一个客户单操作，每个客户端操作的代码又放在不同的CommandExecutorI实现类下，而框架显示的将操作分为查询操作和命令操作来实现读写分离，实现了各个功能模块的解耦。 client包作为约束客户端（APP）层的重要模块，其下面定义了一个CustomerServiceI接口，此结构的实现类由app层去实现，这种依赖反转的方式很好的控制了app端能做什么也简化了开发。 domain包为领域开发人员所使用的包，领域开发人员将设计的领域模型都放在此提供app层和infrastructure层去调用 infrastructure包可以由数据库开发人员去实现，里面包含领域对象持久化内容和一些基础服务，并且其提供了一个SpringBean的配置文件负责整合了框架 核心源码解析在demo app层中我们发现了被@Command注解的实现类 123456789101112@Commandpublic class CustomerListByNameQryExe implements QueryExecutorI&lt;MultiResponse&lt;Customer&gt;, CustomerListByNameQry&gt; &#123; @Override public MultiResponse&lt;Customer&gt; execute(CustomerListByNameQry cmd) &#123; List&lt;Customer&gt; customerList = new ArrayList&lt;&gt;(); Customer customer = new Customer(); customer.setCustomerName(&quot;Frank&quot;); customerList.add(customer); return MultiResponse.ofWithoutTotal(customerList); &#125;&#125; 在app服务类调用中仅仅是将customerListByNameQry对象发送给CommandBusI（CommandBus总线）即完成调用 1234567891011121314151617@Servicepublic class CustomerServiceImpl implements CustomerServiceI &#123; @Autowired private CommandBusI commandBus; @Override public Response addCustomer(CustomerAddCmd customerAddCmd) &#123; return (Response)commandBus.send(customerAddCmd); &#125; @Override public MultiResponse&lt;Customer&gt; listByName(CustomerListByNameQry customerListByNameQry) &#123; return (MultiResponse&lt;Customer&gt;)commandBus.send(customerListByNameQry); &#125;&#125; 我们使用编译器进入CommandBusI实现类发现CommandBusI下对应着一个CommandBus的实现类 123456789101112@Componentpublic class CommandBus implements CommandBusI&#123; @Autowired private CommandHub commandHub; @Override public Response send(Command cmd) &#123; return commandHub.getCommandInvocation(cmd.getClass()).invoke(cmd); &#125;&#125; 我们再进入CommandHub查看getCommandInvocation方法，发现其实CommandInvocation是从一个HashMap中来的，那么HashMap里的值是合适初始化的呢 12345678private Map&lt;Class/*CommandClz*/, CommandInvocation&gt; commandRepository = new HashMap&lt;&gt;();public CommandInvocation getCommandInvocation(Class cmdClass) &#123; CommandInvocation commandInvocation = commandRepository.get(cmdClass); if (commandRepository.get(cmdClass) == null) throw new ColaException(cmdClass + &quot; is not registered in CommandHub, please register first&quot;); return commandInvocation; &#125; 在infrastructure模块下我们发现框架的入口配置类ColaConfig 123456789101112@Configurationpublic class ColaConfig &#123; @Bean(initMethod = &quot;init&quot;) public Bootstrap bootstrap() &#123; Bootstrap bootstrap = new Bootstrap(); List&lt;String&gt; packagesToScan = new ArrayList&lt;&gt;(); packagesToScan.add(&quot;com.liu&quot;); bootstrap.setPackages(packagesToScan); return bootstrap; &#125;&#125; 于是我们定位到框架的入口,顺着初始化代码在源码COLA-master的cola-framework下找到Bootstrap类,找到初始化方法init 1234public void init() &#123; Set&lt;Class&lt;?&gt;&gt; classSet = scanConfiguredPackages(); registerBeans(classSet); &#125; 看到这里我们就已经明白了scanConfiguredPackages（）方法是扫描编译目录下的Class文件，registerBeans是注册bean对象我们进入registerBeans方法,发现其遍历之前扫描的class文件,并且传入在registerFactory 123456789private void registerBeans(Set&lt;Class&lt;?&gt;&gt; classSet) &#123; for (Class&lt;?&gt; targetClz : classSet) &#123; RegisterI register = registerFactory.getRegister(targetClz); if (null != register) &#123; register.doRegistration(targetClz); &#125; &#125; &#125; 进入registerFactory.getRegister(targetClz)方法，发现代码在registerFactory中根据类上的注解返回对应的注册器，之前对应的@Command注解对应的就是为commandRegister注册器 1234567891011121314151617181920212223public RegisterI getRegister(Class&lt;?&gt; targetClz) &#123; PreInterceptor preInterceptorAnn = targetClz.getDeclaredAnnotation(PreInterceptor.class); if (preInterceptorAnn != null) &#123; return preInterceptorRegister; &#125; PostInterceptor postInterceptorAnn = targetClz.getDeclaredAnnotation(PostInterceptor.class); if (postInterceptorAnn != null) &#123; return postInterceptorRegister; &#125; Command commandAnn = targetClz.getDeclaredAnnotation(Command.class); if (commandAnn != null) &#123; return commandRegister; &#125; Extension extensionAnn = targetClz.getDeclaredAnnotation(Extension.class); if (extensionAnn != null) &#123; return extensionRegister; &#125; EventHandler eventHandlerAnn = targetClz.getDeclaredAnnotation(EventHandler.class); if (eventHandlerAnn != null) &#123; return eventRegister; &#125; return null; &#125; 我们再看commandRegister中的doRegistration方法，现在结果一目了然，这里获取Spring容器中的CommandInvocation对象，并且调用commandHub.getCommandRepository().put(commandClz, commandInvocation)将之前被@Command注解的实现类传入commandRepository中也就是之前上面从HashMap中获取CommandInvocation的地方，代码中还提供了自定义AOP功能，但这部分并未开发接口，至此，整个框架的代码流程就已清晰。 123456789@Override public void doRegistration(Class&lt;?&gt; targetClz) &#123; Class&lt;? extends Command&gt; commandClz = getCommandFromExecutor(targetClz); CommandInvocation commandInvocation = ApplicationContextHelper.getBean(CommandInvocation.class); commandInvocation.setCommandExecutor((CommandExecutorI) ApplicationContextHelper.getBean(targetClz)); commandInvocation.setPreInterceptors(collectInterceptors(commandClz, true)); commandInvocation.setPostInterceptors(collectInterceptors(commandClz, false)); commandHub.getCommandRepository().put(commandClz, commandInvocation); &#125;]]></content>
      <categories>
        <category>领域驱动设计(DDD)</category>
      </categories>
      <tags>
        <tag>领域驱动设计</tag>
        <tag>COLA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[领域驱动设计DDD简介]]></title>
    <url>%2F2019%2F09%2F03%2F%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1DDD%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[什么是领域驱动设计 接触领域驱动设计已经有一年多的时间了，其更关注的是解决复杂的软件设计。这期间也拿一些小项目尝试实践过，也看过一些领域驱动的框架如Halo，Cola,在实践过程中发现如果小项目如果采用简化版的领域驱动设计的理念去实践，代码结构也会有明显的改善，在小项目实践过程中更关注的是边界的划分，和不同功能模块代码的解耦，把核心的领域代码和其它代码区分出来，更好的将代码和现实业务结合起来，更好的执行面向对象，在使用领域驱动设计时能让我们从数据库驱动设计的理念中转换出来，在设计时假设计算机内存是无限大，只考虑领域模型，而不考虑数据库模型，从而使代码更贴近业务，我觉得这是领域驱动设计给我带来的感触。就比如架构，架构的本质无非就是把代码的边界区分好，把代码放在该放的地方Eric Evans提出的领域驱动设计是一个很好的解决这部分问题的方法。领域驱动设计，领域代表着行业，你的软件是应用在哪个行业实现什么样的功能，比如你编写了一个财务软件，那么财务行业就是你编写软件的领域，Eric Evans强调软件一定是要由领域专家和领域知识去驱动开发的，因为软件最终是要应用到领域当中，如果绕过这部分内容直接开发软件，那么开发的软件往往无法交付或者无法满足功能，在我认为，软件是现实生活中的映射，在开发第一个版本的时候，可以和领域专家或者领域中的从业人员进行交流业务流程(现实往往只能找到产品经理)，交流一下在没有软件的情况下，线下业务是如何进行的，然后再根据这些流程去建立领域对象，去驱动整体的软件设计。 领域驱动设计的核心概念通用语言 在开发准备之前必须要和领域人员(如果没有，那只能是需求人员)建立好一套通用的开发语言，我曾经在没接触过过领域驱动设计时实现一个功能时并没有和当时对应需求人员建立一套通用的语言，就是产品说的一个名词和你说的名词并不是同一个名词，但是你以为你理解了产品经理的意思，然后就去开发，结果到交付时发现整个理念完全错误，导致最后返工。建立通用语言的过程往往要经过反复沟通后才能得出的，在反复沟通的过程中，抓住一个反复提及的名词，然后确定这个名词代表的含义，反复提及的名词往往就是找到通用语言的关键,在软件建模中也要紧紧围绕这个名词去建模，当你建立完模型后（通常是UML图），把这部分模型拿给领域专家看，因为你这时候的模型就代表着现实的业务，和领域人员确认模型这样设计是否合理。 领域模型贫血型模型 在领域驱动设计中Eric Evans一直不赞成使用贫血型模型，什么是贫血型模型，简单来说就是我们平常建立的java bean对象，只包行一些字段和get，set方法，因为贫血型对象不能很好的展示出领域模型，有一些本该属于领域模型的方法外泄到其它类比如Service类中去了，所有和领域相关的代码都要包含在领域模型中或者领域服务中，举个例子,有一个用户信息模型，一般我们是这样设计和调用的 12345678910111213141516171819202122public class User &#123; private String userId; private String userName; public String getUserId() &#123; return userId; &#125; public void setUserId(String userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125;&#125; 现在我要修改用户的名字那边就要用Service去实现 1234567891011public class UserService &#123; public void changeUserName(String userName,User user)&#123; if(userName!=null)&#123; user.setUserName(userName); &#125; &#125;&#125; 认真考虑一下现实项目中采用上文编写代码所产生的问题 代码不能很好的体现业务changeUserName这个方法应该是属于用户类中的方法，但是现实中该类却放在了调用方的Service中，上文提到了通用语言，在和领域人员沟通时，他们会说到用户修改了用户名，这里作用的主体是用户，只有用户有权利修改自己的用户名，但是体现在代码中却变成了用户把修改用户名的权利交给了调用方，这样的代码并不能很好的反应出业务，也并不是很好的面向对象的模型。 Service上帝类采用上述方法去建模，将会导致service类的代码快速膨胀，久而久之service类负责所有的功能，包括校验，对象持久化，远程调用等待代码，如果在项目开始时还可以接受，但是随着时间的发展，service变成了乱麻，再也没有人能够轻松分清里面的逻辑了。 充血模型 现在我们采用充血模型实现上述代码 12345678910111213public class User &#123; private String userId; private String userName; public void updateUserName(String userName) &#123; if(userName!=null)&#123; this.userName=userName; &#125; &#125;&#125; 现在我们将原本存在Service中的updateUserName方法放到领域模型中，就修改用户名时传入用户名即可完成用户名修改，这完全符合通用语言的用户修改了用户名，并且在修改用户名时候进行了校验，校验本身也是领域对象提供的功能之一，修改用户名的规则应该由领域对象去觉得，而不是由调用方去决定 现在第三方人员修改用户名变的简单了,再也不需要处理本该属于领域对象校验等功能，这样将属于领域的代码和属于调用方的代码很好的分开,代码的层次也更加分明。 12345678public class UserService &#123; public void changeUserName( User user,String userName) &#123; user.changeUserName(userName); &#125; &#125; 实体（Entity） 采用领域驱动设计建模的一个很重要的概念就是实体,书中给的定义是主要由标识定义的对象称为实体(Entity)，现在我们扩展上诉的User对象，在对象里加入一个Address家庭住址对象 12345678 public class User &#123; private String userId; private String userName; private Address address;&#125; 家庭住址对象包含街道名和邮编 123456public class Address &#123; private String street; private String postcode;&#125; 在通用语言中我们会这样描述，我想根据用户id找到对应用户所居住的地址，这里的用户id就是User的标识定义，那么我们认为User它就是一个实体，但是这里的Address并不是实体，它只是一个VO(键值对对象)在用户模型中给地址一个唯一标识定义是没有意义的，因为在用户跟换地址时我直接将整个Address对象替换掉即可，我并不关心地址的状态。 在现实模型中同一个事物可能需要标识为实体，也有可能不需要表示实体，举个例子上述的User为实体，但是换一个场景，订单对象下关联了一个用户对象来表明这个订单是谁买的，在这里我们关注的是订单，把用户作为实体是没有意义的，所以这里订单是实体，User只是一个VO(键值对对象) VO很多对象没有概念上的标识，它们描述了一个事务的某种特性,我们称这些对象为VO 如果将所有对象设计成实体会有什么问题？在书中有一个很好的例子：小孩子总是可以很好的分清楚那副画是自己画的，因为每幅画都有一些标识来区分哪些是自己画的哪些不是，但是如果必须记住哪些线条使用哪只笔画的那情况该有多复杂？上文的User对象的Address就是一个VO，因为我并不关心Address 的状态，它在User对象中只是单纯是键值属性，但是什么情况下地址为实体什么情况下为VO呢？书中举了另外一个例子:在购物系统中需要用地址来标识发货地址，如果室友也从这家店购买了商品，那么意识到他们是否住在同一个地方并不重要（不需要维护地址标识），这里是地址是VO,如果你和舍友同时去申请宽带，那么这里的地址就是实体，因为电信公司需要知道你和你的舍友居住在同一个地方，这样他们只要上门一次即可。 另一个VO的重要特性是VO是可以整个被替换的，其没有包含副作用的方法，举个例子上文User关联的Address对象,将Address对象传给其它人调用里面的方法并不会对User类产生影响，因此可以放心的将VO传给任何人调用，在设计中尽量将对象设计成VO来减少系统的复杂性，大举个例子，上文中User如果修改Address如果Address的话我们直接在User对象中整个替换Address对象即可完成地址的修改，但是如果地址为实体的话，那么我们必须用地址标识还原出Address对象，然后将地址对象的属性做修改 领域服务 在书中是给领域服务这样定义的：在领域中的某个操作过程或转换过程不是实体或者值对象（VO）的职责时，我们应该将操作放在一个单独的接口中，即领域服务，请确保领域服务和通用语言是一致的，并且保证它是无状态的。 在现实代码中我更喜欢把领域当成客户端调用的代码，领域模型由建模人员编写完代码，然后将这部门代码交给客户端人员去调用，领域建模人员必须保证客户端代码的易用性，如果有些方法并不适合在领域模型中，那么可以将其放在领域服务中，这样可以对客户端人员屏蔽领域细节，例如用户登录时可能涉及到鉴权，鉴权部分可能是另一个模型对象，如果我们不使用领域服务将这些工作全部交给客户端人员去做的话，那么客户端的程序员就必须知道业务的逻辑，要知道原来登录要先鉴权，他先去执行鉴权代码再去执行验证用户密码的代码，这样就导致领域信息暴露，更好的做法应该是用领域服务将鉴权和验证用户信息的方法放在领域服务中，然后再对外暴露一个登陆验证的服务，这样就对客户端程序员屏蔽了领域信息，他只需要调用一个登陆的领域服务即可，不用去关心领域里的逻辑,关于领域服务的具体实践和分包我讲在后续小项目领域驱动实践中介绍。 聚合 在日常开发中将实体和VO进行聚合组成聚合对象是非常普遍的，我们将这些对象称之为聚合，聚合对象都有一个主体我们称之为聚合跟，在使用聚合时对客户端程序员暴露的都应该是聚合根，而不是聚合根下的对象，举例 123456789101112 public class User &#123; private String userId; private String userName; private Address address; public void saveAddress(Address address)&#123; this.address=address; &#125;&#125; 上文中的User对象包就是一个聚合它包含了用户的用户名，用户id属性，也包含了一个地址VO，我们在对外提供领域模型给客户端程序员时我们只能建User对象中的方法,比如上文的saveAddress保存地址方法，而不是将一个个调用Address对象中的get set方法。在实际设计过程中有时候由于聚合包含太多的VO和实体导致聚合过于庞大，我们可以将聚合进行拆分，具体的实践方法我讲在后续小项目领域驱动实践的文章中表述。 资源库（Repository） Repository对领域模型屏蔽了持久化的代码，因为现实软件设计中领域对象不可能全部都存留在内存中，当一个领域对象从创建开始我们就认为其已开始其的生命周期，即使后续将这个领域对象存储在数据库等持久化的对象中我们仍然认为其仍处于生命周期内，直到我们在数据库中将其删除我们才认为一个领域对象生命的结束，资源库就是为了在领域对象存储在数据库或者其它一些持久化组件中时将其还原成领域对象而设计的，比如如下代码 1234567891011121314public class UserRepository &#123; public void addUser(User user)&#123; //持久化代码 &#125; public User findUserById(String userId)&#123; //模拟从数据库中生成对象 User user=new User(); return user; &#125;&#125; 在客户端服务调用完领域服务生成领域对象后，客户端将领域对象传入到资源库中将其持久化(addUser)，同样，资源库也可以根据各种条件去还原一个领域对象（findUserById） 架构设计（六边形架构） 在采用领域驱动设计时我采用的是六边形架构如图 下面是我在网上摘抄的对六边形架构的简介 六边形架构还是一种分层架构，如上图所示，它被分为了三层：端口适配器、应用层与领域层。而端口又可以分为输入端口和输出端口。 输入端口用于系统提供服务时暴露API接口，接受外部客户系统的输入，并客户系统的输入转化为程序内部所能理解的输入。系统作为服务提供者是对外的接入层可以看成是输入端口。 输出端口为系统获取外部服务提供支持，如获取持久化状态、对结果进行持久化，或者发布领域状态的变更通知（如领域事件）。系统作为服务的消费者获取服务是对外的接口（数据库、缓存、消息队列、RPC调用）等都可以看成是输入端口。 应用层定义系统可以完成的工作，很薄的一层。它并不处理业务逻辑通过协调领域对象或领域服务完成业务逻辑，并通过输入端口输出结果。也可以在这一层进行事物管理。 领域层负责表示业务概念、规则与状态，属于业务的核心。 应用层与领域层的不变性可以保证核心领域不受外部的干扰，而端口的可替换性可以很方便的对接不用的外部系统 我在这里对以上的解释说明下 输入端口在上图中对应适配器A,B,C,D比如在http服务中其对应的就是Controller层，用Spring的话就是SpringMVC框架，适配器完成了http对应用用程序的转化，因为应用层提供了固定的API来满足各种渠道的调用，比如现在我要增加一个人RPC调用，我只要根据应用层所提供的API写一个转换器将应用层的API转化成RPC调用的方法即可，图中领域模型作为为核心最稳定的内容放在了六边形的中央，其它所有的组件都必须依赖领域模型，这符合了领域驱动的模型。最后是输出端口，我们将持久化的代码放入这里（资源库Repository）下面给出我们架构设计的依赖结构* 输出层 -&gt; 应用程序(APP) -&gt; 资源库（Repository）-&gt; 领域层 实际中领域层中的领域服务有可能会调用到资源库（Repository），但是我们又不能让领域层去依赖资源库层，因为领域层是项目的核心，应该是最稳定的部分，会被大量的组件依赖，而资源库层相对领域层更加不稳定（比如数据库中新增一个字段等），那么我们这里就要用依赖倒置技术使资源库依赖领域层，具体实践放在小项目领域驱动实践中去讲解*]]></content>
      <categories>
        <category>领域驱动设计(DDD)</category>
      </categories>
      <tags>
        <tag>领域驱动设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[greenplum集群安装]]></title>
    <url>%2F2019%2F09%2F02%2Fgreenplum%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Greenplum集群搭建 关闭所有主机防火墙12systemctl stop firewalld.servicesystemctl disable firewalld.service 关闭SELINUX 12vi /etc/selinux/config将属性 SELINUX 改为 disabled 系统设置设置hostname12345vi /etc/hosts添加各个主机的hostname如:192.168.171.75 master192.168.171.76 node1192.168.171.77 node2 设置系统参数至sysctl.conf12345678910111213141516171819202122232425262728vi /etc/sysctl.conf在文件中添加以下代码kernel.shmmax = 500000000kernel.shmmni = 4096kernel.shmall = 4000000000kernel.sem = 500 2048000 200 40960kernel.sysrq = 1kernel.core_uses_pid = 1kernel.msgmnb = 65536kernel.msgmax = 65536kernel.msgmni = 2048net.ipv4.tcp_syncookies = 1net.ipv4.conf.default.accept_source_route = 0net.ipv4.tcp_max_syn_backlog = 4096net.ipv4.conf.all.arp_filter = 1net.ipv4.ip_local_port_range = 10000 65535net.core.netdev_max_backlog = 10000net.core.rmem_max = 2097152net.core.wmem_max = 2097152vm.overcommit_memory = 2vm.swappiness = 10vm.zone_reclaim_mode = 0vm.dirty_expire_centisecs = 500vm.dirty_writeback_centisecs = 100vm.dirty_background_ratio = 0vm.dirty_ratio = 0vm.dirty_background_bytes = 1610612736vm.dirty_bytes = 4294967296 在/etc/security/limits.conf中修改以下参数123456vi /etc/security/limits.conf修改以下参数* soft nofile 65536* hard nofile 65536* soft nproc 131072* hard nproc 131072 同步集群时间1234567891011在所有主机上安装ntpyum install -y ntp添加如下内容server 127.127.1.0fudge 127.127.1.0 stratum 10保存退出，然后启动ntp 服务并设为开机启动：systemctl start ntpdsystemctl enable ntpd在集群其他节点安装ntp 服务，并将ntp 服务server 指向主节点echo &quot;server &lt;ip&gt; iburst&quot; &gt; /etc/ntp.conf&lt;ip&gt; 替换为主节点ip 地址 免密登录1234567891011121314151617181920用root用户登录所有主机编辑文件 /etc/ssh/sshd_config将以下两行前面的#号去掉，保存RSAAuthentication yesPubkeyAuthentication yes在所有主机上执行以下命令ssh-keygen -t rsa按四下回车得到public key在所有主机上执行以下命令，将所有主机的public key 拷贝到主节点上ssh-copy-id root@&lt;hostname&gt;&lt;hostname&gt;更换为主节点主机的主机名在主节点机器上通过scp 命令将文件 /root/.ssh/authorized_keys 发送到所有其他节点主机的 /root/.ssh/ 目录下：scp /root/.ssh/authorized_keys root@&lt;hostname&gt;:/root/.ssh/重启所有主机的sshd 服务systemctl restart sshd.servicesystemctl enable sshd.service验证免密码登陆 ：ssh &lt;hostname&gt;&lt;hostname&gt; 更换为主机名。 在主节点安准Greenplum123456rpm -Uvh ./greenplum-db-&lt;version&gt;-&lt;platform&gt;.rpm数据库软件安装在/usr/local/greenplum-db-&lt;version&gt;目录下修改目录权限为gpadmin所有chown -R gpadmin /usr/local/greenplum*chgrp -R gpadmin /usr/local/greenplum* 在集群中安装Greenplum1234567891011121314151617181920su -切换至root用户touch hostfile_exkeys创建一个hostfile_exkeys文件将所有主机hostname放入其中（主机包含所有master, standby master,segments）如mdwmdw-1mdw-2smdwsmdw-1smdw-2sdw1sdw1-1sdw1-2sdw2sdw2-1sdw2-2sdw3sdw3-1sdw3-2 12345创建groupadd账号和groupadd组groupadd gpadminuseradd gpadmin -g gpadminpasswd gpadmin 1234567安装Greenplum rpm包rpm -Uvh ./greenplum-db-&lt;version&gt;-&lt;platform&gt;.rpm数据库默认安装在/usr/local/greenplum-db-&lt;version&gt;目录下更改安装目录权限为gpadmin用户所有 chown -R gpadmin /usr/local/greenplum* chgrp -R gpadmin /usr/local/greenplum* 12345678910111213141516171819202122232425262728将安装分发给集群其它主机执行创建一个空文件touch hostfile_exkeys将集群所有hostname写入文件，如: mdw mdw-1 mdw-2 smdw smdw-1 smdw-2 sdw1 sdw1-1 sdw1-2 sdw2 sdw2-1 sdw2-2 sdw3 sdw3-1 sdw3-2执行以下命令在集群中安装数据库gpseginstall -f hostfile_exkeys确认集权是否安装成功su - gpadminsource /usr/local/greenplum-db/greenplum_path.shgpssh -f hostfile_exkeys -e ls -l $GPHOME如果可以看到集群信息则安装成功 创建数据目录12345678在主节点中创建目录，目录地址根据实际情况更改mkdir -p /data/master改变目录所有者chown gpadmin /data/master如果有副主节点，执行以下命令在副主节点中创建相同目录，smdw为副主节点hostnamesource /usr/local/greenplum-db/greenplum_path.shgpssh -h smdw -e &apos;mkdir -p /data/master&apos;gpssh -h smdw -e &apos;chown gpadmin /data/master&apos; 创建段节点（数据节点）目录123456创建空文件touch hostfile_gpssh_segonly将所有段节点（数据节点）的hostname填入如:sdw1sdw2sdw3 用gpssh命令在段节点(数据节点)创建目录和更改其权限1234source /usr/local/greenplum-db/greenplum_path.shgpssh -f hostfile_gpssh_segonly -e &apos;mkdir -p /data/primary&apos;gpssh -f hostfile_gpssh_segonly -e &apos;mkdir -p /data/mirror&apos;gpssh -f hostfile_gpssh_segonly -e &apos;chown -R gpadmin /data/*&apos; 配置数据库123456789101112131415161718192021222324252627282930313233343536切换至gpadminsu - gpadmincp $GPHOME/docs/cli_help/gpconfigs/gpinitsystem_config /home/gpadmin/gpconfigs/gpinitsystem_config备份配置文件到新目录下修改备份文件gpinitsystem_config，修改以下参数DATA_DIRECTORY（将创建主段数据目录的文件系统位置,有几个DATA_DIRECTORY, 每个节点上便会启动几个segments#### 指定Primary Segment的数据目录, DATA_DIRECTORY参数指定每个Segment主机配置多少个Instance。如果#### 在host文件中为每个Segment主机列出了多个网口，这些Instance将平均分布到所有列出的网口上。#### 这里的案例，hosts里有2个segment，sdw1，sdw2俩主机，都是单网卡段的数量划分要根据服务器的cpu，网卡，磁盘因数划分最好达到share nothing的效果，每个段都有独自的处理器，磁盘或者网卡）MASTER_HOSTNAME(主节点hostname)MASTER_DIRECTORY（将创建主数据目录的文件系统位置）MIRROR_DATA_DIRECTORY（建立节点的镜像mirror节点的地址，镜像的数量必须和DATA_DIRECTORY的数量一致）详细参数说明查阅https://gpdb.docs.pivotal.io/5190/utility_guide/admin_utilities/gpinitsystem.html----------------------------------------------------------------ARRAY_NAME=&quot;Greenplum Data Platform&quot;SEG_PREFIX=gpsegPORT_BASE=40000declare -a DATA_DIRECTORY=(/data/primary)MASTER_HOSTNAME=mdwMASTER_DIRECTORY=/data/masterMASTER_PORT=5432TRUSTED SHELL=sshCHECK_POINT_SEGMENTS=8ENCODING=UNICODE...MIRROR_PORT_BASE=7000REPLICATION_PORT_BASE=8000MIRROR_REPLICATION_PORT_BASE=9000declare -a MIRROR_DATA_DIRECTORY=(/data1/mirror /data1/mirror /data1/mirror /data2/mirror /data2/mirror /data2/mirror)----------------------------------------------------------------- 运行初始化脚本1234567891011121314151617181920 创建文件里面所有段节点（数据节点）hostname touch vi hostfile_gpinitsystem 数据如: sdw1-1 sdw1-2 sdw2-1 sdw2-2 sdw3-1 sdw3-2 sdw4-1 sdw4-2执行以下命令，gpconfigs/gpinitsystem_config为上面更改的配置文件，hostfile_gpinitsystem为所有的段节点hostname，standby_master_hostname为副主节点的hostnamecd ~gpinitsystem -c gpconfigs/gpinitsystem_config -h gpconfigs/hostfile_gpinitsystem \ -s standby_master_hostname -S 当出现Continue with Greenplum creation? Yy/Nn时 输入y回车 出现以下提示表示安装成功 Greenplum Database instance successfully created. 在主节点和备份主节点设置环境变量12345678su - gpadminvi ~/.bashrc添加以下内容，MASTER_DATA_DIRECTORY为实际master目录路径source /usr/local/greenplum-db/greenplum_path.shexport MASTER_DATA_DIRECTORY=/data/master/gpseg-1(注意)如果是RHEL 7 or CentOS 7系统，需要在.bashrc文件的末尾添加如下内容:export LD_PRELOAD=/lib64/libz.so.1 ps至此安装完成 设置账号123456789登录master节点运行psql修改管理员密码alter role gpadmin with password &apos;hzt_2019&apos;;输入\q退出客户端设置账号访问权限,路径根据实际路径填写vi /data/master/gpseg-1添加以下代码，设置gpadmin可远程登录host all gpadmin 0.0.0.0/0 trust]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>greenplum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓慢维度的设计和处理]]></title>
    <url>%2F2019%2F09%2F02%2F%E7%BC%93%E6%85%A2%E7%BB%B4%E5%BA%A6%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于缓慢维度变化的简介 在数据仓库设计中理想状态下维度是不会变化的，但是事与愿违，大部分业务系统中的维度是会发生变化的，那么如何去处理这些变化的维度就是本文关注的内容，举个例子如下企业组织架构维度表 ID_ 企业名 部门名 组名 1 微软 研发部 开发一组 如果有一天上表中的部门名发生变化怎么办?根据Kimball的数据仓库工具箱，我们把处理缓慢维度的方法分为7种类型，其为类型1至类型7 类型1:重写 顾名思义，就是将维度表中的字段简单的替换，如上表中如果采用类型1的话，如果部门后续由研发部变成技术部，那么维度表将变成下表，部门维度表和部门人数事实表做关联 ID_ 企业名 部门名 组名 1 微软 技术部 开发一组 部门人数事实表 ID_ 部门ID外键 人数 1 1 10 类型1的优劣势 有点是简单易于实现，仅需重写维度表中的属性值而不需要去更改事实表，但是无法保留历史值，如果业务中存在对维度的历史值进行分析，那么就无法采用该类型，举例：采用类型1将部门名改成技术部后，现在需要分析在部门叫研发部时，研发部下有多少人?那么如果采用类型1将无从下手，因为维度表中没有保存历史维度数据,而部门人数事实表中的数据是用部门ID去与其关联的。但是实际中如果采用类似hive无法执行update语句的数据仓库工具去建设的话，那么只能重新全量生成维度表 类型2：增加新行 类型2是最常用的处理缓慢维度的办法,如果采用此设计方式则在部门名变更为技术部时维度表和事实表如下 ID_ 企业名 部门名 组名 行有效日期 行失效日期 是否生效 1 微软 研发部 开发一组 2011-1-1 2019-9-1 no 2 微软 技术部 开发一组 2019-9-2 9999-1-1 yes 部门人数事实表 ID_ 部门ID外键 人数 1 1 10 2 2 100 在事实表中原来旧的数据仍然和研发部关联，但是新增的数据已经和新的维度（技术部）做关联。这样数据就保留了历史变化的信息，如果需求中存在对历史维度进行分析的话可以采用此类型应对维度缓慢维度变化。 类型3：新增新列 采用维度2去处理维度变化时存在一个缺点，如果需求需要将新的属性值和旧的属性值做关联分析，那么采用类型2将很难实现，因为类型2并没有记录维度变化的关联关系，如果存在这方面需求则可以采用类型3处理，事实表通过代理键ID关联维度表(维度表在创建时自己生产的id，不是业务方提供的ID)但实际中类型3不经常使用 如： ID_ 企业名 当前部门名 之前部门名 组名 1 微软 技术部 研发部 开发一组 部门人数事实表 ID_ 部门ID外键 人数 1 1 10 类型4：微型维度 其解决问题的场景为应对维度表中存在大量数据（几百万），且一些属性快速变化。因为当维度表中存在大量的数据，特别是维度中某些信息还是易变时，我们不希望已经存在几百万的维度表中新增数据（采用类型2），因为这样会使维度表发生膨胀，实际情况中维度表中的数据应该远远小于事实表，那么类型3就派上用场，还是引用上诉两张表，假设现在部门维度有几十万个部门，且组名经常发生变化（即使不太可能），那么我们将才用下面设计 部门表 ID_ 企业名 部门名 1 微软 研发部 组名表 ID_ 组名 1 开发一组 1 开发二组 部门人数事实表 ID_ 部门ID外键 组名外键 人数 1 1 1 10 2 1 2 100 部门表和组名表不再使用星型维度直接做关联，而是在事实表中新建外键来关联部门和组 类型5：微型维度与类型1支架表 之所以称之为类型5是因为其是类型4和类型1的结合 4+1=5，该技术实现为在主维度中用一个外键id和一个微型维度做关联，这样能避免微型维度发生变化时更新主维度的每行的信息，且如果客户需求需要在不关联事实表的情况下完成维度的过滤分析等类型5是很好的处理方法，举例 商店维度表 ID_ 商店名 地区ID 1 一号门店 1 地区维度表 地区ID 省 市 县 1 福建省 福州市 闽清县 如果不采用类型5的话维度表结构为 ID_ 商店名 省 市 县 1 一号门店 福建省 福州市 闽清县 2 二号门店 福建省 福州市 闽清县 那么有一条闽清县更改了名字变成闽清市，如果不采用类型5支架表的话那么将要更改所有商店维度表中有关闽清县的记录，将其改成闽清市，如果你在很多事实表中都使用了地区信息，那就需要更改所有有关地区的维度，这是无法忍受的，但是如果采用类型5则只需要更改地区类型的属性即可完成所有有关地区维度信息的修改。 类型6 类型6为 类型2,3,1的组合（2+3+1=6），回顾类型3，当为了记录维度变化的历史先后关系时我们采用类型3，但是类型3也有一个缺点就是它只记录当前的变化，和上一次的变化，类型6解决了这个问题，其维度表如： ID_ 企业名 当前部门名 之前部门名 组名 生效日期 结束日期 当前是否生效 1 微软 技术部 研发部 开发一组 2011-1-1 2019-9-1 no 2 微软 技术部2 技术部 开发一组 2011-1-1 9999-1-1 yes 部门人数事实表 ID_ 部门ID外键 人数 1 1 10 尽管该技术具有某种诱惑力，但是加大了系统的复杂度，考虑任务是否有这种需求才使用这种方法。 类型7 当需要分析维度表的当前和历史场景的时候可以使用类型7，其运用事实表关联类型2和基于类型2的维度表创建一个当前部门的视图来实现，如下 部门维度 ID_ 部门编码 企业名 当前部门名 生效日期 结束日期 当前是否生效 1 code1 微软 研发部 2011-1-1 2019-9-1 no 2 code1 微软 技术部 2011-1-1 9999-1-1 yes 当前部门视图（可以根据部门问题创建一个当前部门视图 比如:select * from 部门维度 where 当前是否生效=’yes’） 部门编码 部门ID 当前部门名 code1 2 技术部 code1 3 人力资源部 部门人数事实表 ID_ 部门ID外键 部门编码 人数 1 1 code1 10 2 2 code1 10 这样通过事实表中存在，部门ID外键和部门编码就可以分析历史部门数据和当前部门数据所存在的关系 杂项目维度 在建模过程中通常会遇到大量五花八门的指标和描述，它们包行小的范围离散值处理这些离散值有一下几种方法 忽略这些标志和指标,如果这些描述具有业务价值则不能采用这种方式 在事实表中保存这些表示，尽量不要在事实表中保存这些描述，这些描述可能使事实表的列发生膨胀 将每个标志和指标放入各自的维度，如果事实表的外键在合理范围内（不超过20个），则在事实表中加入不同的外键是可接受的。 杂项维度,如下 在交易事实表中存在以下杂项描述 支付方式:CASH,CREDIT购买渠道:ONLINE,OFFLINE对应事实表中一共存在以下4中组合方式（2的二次方），数据为 支付方式 购买渠道 CASH ONLINE CASH OFFLINE CREDIT ONLINE CREDIT OFFLINE 那么与其建这些杂项目反正事实表中，或者维度数目已经较大的情况下，我们可以创建一个杂项维度,将这些杂项的所有可能罗列出来如 ID 支付方式 购买渠道 1 CASH ONLINE 2 CASH OFFLINE 3 CREDIT ONLINE 4 CREDIT OFFLINE 现在在事实表中的数据为 ID_ 杂项外键 金额 1 2 100 2 1 1000 不同粒度的事务事实（表头模式） 实践中应该避免这么模式，应该保证事实表中的粒度和维度是一样的 比如存在订单详细事实表 ID_ 订单ID 商品外键 金额 1 order1 1 1000 2 order1 2 888 订单维度表 ID_ 订单描述 order1 订单1信息 order1 订单2信息 这样的设计存在一个问题，订单详情事实表中的粒度是订单的每个商品，但是却关联了订单维度，这两个关联存在不同的粒度，应该尽量避免这种情况，更好的做法应该是再新建一个关于订单的事实表，在订单明细表中将订单id做为退化维度（只是单纯的记录一下订单id，为了方便分析） 多币种 最常见的分析需求是订单事务以当地交易币种表示，在构建订单事实表时应该包含2种货币信息事实，一种是当地货币，一种是公司采用的标准统计货币，比如公司在日本销售的货物以日元结算，公司财报中的统计标准为美元，那么在订单事实表中应该包行2种货币，一种是日元，一种是公司的标准货币美元。]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>维度</tag>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据仓库维度建模概述]]></title>
    <url>%2F2019%2F08%2F31%2F%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是维度 简单的来说维度就是用于分析数据仓库中的事实的描述（关于事实下文讲解）.举个例子在数据库中有两张表，订单明细表和商品表 订单明细表 ID_ ORDER_ID PRODUCT_ID_ quantity 1 1 1 10 商品表 ID_ PRODUCT_NAME 1 华为手机 这两张表中订单明细表使用商品表中的id与之关联，订单明细表为事实表记录了订单明细的事实，商品表就为维度表，因为商品表描述了订单明细表，我们通过商品表中的维度信息去分析订单明细表中的数据，用需求文字来描述就是我想查购买了华为手机的所有订单明细，转换成SQL语句为 1select * from 订单表 t1 inner join 商品表 t2 on t1.PRODUCT_ID_=t2.ID_ where t2.PRODUCT_NAME=&apos;华为手机&apos; 什么是事实 事实一般只是一些单纯的数字，如上文订单表中的数量，它仅仅是订单中的一个度量，没有什么文字描述，文字描述都存在维度表中,通过维度表去分析事实表。 什么是粒度 事实表中的存储数据都要有相同的粒度,粒度用于确定某一事实表中的行表示什么,例如上文订单明细表中的粒度是到商品,不是订单，因为表中有一个产品id，如果该表去掉PRODUCT_ID_和quantity那么该事实表中的粒度就为订单（一个订单中可能包含很多商品）,所有的事实表中的数据都应该有相同的粒度，同样维度表中的关联也需要和事实表中的粒度做对应，就好比上文的订单明细表中最好不要出现订单的维度，比如订单类型等信息. 设计维度的过程选择业务过程 业务过程一般存储在业务系统的关系型数据库中，我们必须根据需求选取对应业务表中的数据，如我需要建立订单为主题的数据集市，则我需要抽取业务系统中关于订单的数据 声明粒度 最好要包行最低粒度，如上文中建立一张订单明细表，而不是只建立订单表，因为细粒度可以根据维度上卷得到粗粒度的数据，反之则不能。 描述维度 维度提供业务的描述，比如谁，什么，何处，何时等。维度表为数据仓库中的灵魂，是数据仓库中最重要的部分，维度描述越丰富，则数据仓库中所挖掘的信息越多。 确认事实 事实涉及业务过程事件的度量,基本上都是以数量值表示，一个事实表中的所有粒度需要保持一致。 数据仓库的分层 目前项目中采用了4层架构分别为 ods贴源层，ods层中存放了业务表中原封不动的数据 dwd数据清洗层,dwd为了清理ods层中的数据 dws主题层,此层获取dwd中的数据根据不同的主题组成不同粒度的事实表和维度供业务方调用 ads层，此层一般为一些汇总数据供前端展示时调用 不同数据集市间的数据划分可以考虑在同一个数据实例中根据表名建立各个数据集市中的4个不同的层，根据表名区分不同数据集市中的表，也可以根据不同数据集市建立不同的数据库实例来存储上文4个层的表，目前由于建立的数据集市较少为了方便才用同一个数据库实例。 数据的仓库架构总线型架构 Kimball总线架构为，在项目开始时，由架构师设计通用维度，这个维度称为总线，设计完成总线后，将总线维度分发给各个数据集市的开发人员同步去开发，比如订单数据集市，库存数据集市。各个集市中的维度根据总线去做扩展，各个数据集市的数据再ads层之前是不做交互的，如果要跨域多个数据集市去分析数据，那么就用通用维度（总线）去连接各个数据集市中的不同事实表去分析数据。 维度表设计 现在维度表的设计一般分为星型结构和雪花型结构 星型结构，采用宽表和冗余的形式存储维度，维度的父子关系都在一张表中关联，不通过外键关联，如下面时间表: id 年 月 日 20190101 2019 01 01 20190102 2019 01 02 那么如果我想查询实时表中id为20190101的数据对应的月份是几月，那么我们可以使用id去时间维度去查找对应的月份 雪花结构,雪花结构的设计更多的用于关系型数据库，上图的时间维度用雪花型表示为年表 id 年 2019 2019 2018 2018 月表 id 月份 1 01 2 02 年月关系表 id year_id month_id 1 2019 1 2 2019 2 两种设计的优缺星型结构：对查找的效率和难度来说更加高效简单，但是存储了大量冗余数据，而且不够灵活不方便修改，如果存在大量描述字段的话，那么冗余结构相比雪花结构使用更大的存储空间雪花结构：数据更加灵活，比如更改维度表的信息不需要更改整个维度的信息，比如上文我要更改月份里面的字段我只需要更改月表中的信息即可，不需要更改整张维度表，但是查询更加麻烦和慢。其实归根到底就是范式设计和非范式设计，在数仓中大多数情况下应该使用星型结构，因为数仓关注的是查询，用存储空间换取查询数据的方便是值得的，至于对于星型结构存在维度变更的问题，我们将在另一篇文章，维度缓慢变化中说明]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>维度</tag>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hive mysql元数据表单的主从备份]]></title>
    <url>%2F2019%2F08%2F30%2Fhive-mysql%E5%85%83%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%8D%95%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[hive元数据库和使用介绍 hive 会将表的元数据信息存储在数据库中，这里采用mysql作为元数据库存储hive的元数据 元数据表中记录着很多hive中有用的信息，比如数据库实例，表，表结构，还有表数据的条数 表数据条数只有在hive为内部表时的统计是准确的，如果建立的表为外部表 (external)则需要执行统计语句才能得到准确结果 1ANALYZE TABLE tablename COMPUTE STATISTICS; 使用元数据表中的统计数据可以很简单快捷的得到hive的元数据，比如表的数量，和数据量 mysql主从介绍 mysql主从时利用mysql的日志来完成主从的，所以在做主从设置时，先要保证主数据库和从数据库数据的一致 迁移数据 如果主数据库中已经在做主从时已经存在数据那么，先将主数据库中数据复制到从数据库中，从而保证主数据库和从数据库数据的一致 配置主数据库配置文件 1234567891011vi /etc/my.cnf#将以下信息填入server-id = 1 #Mysql服务的唯一编号 每个mysql服务Id需唯一log-bin=mysql-bin #logbin的名字binlog-do-db=metastore #需要同步的数据库的名字，如果是多个数据库存在多条binlog-ignore-db=test01 #不需要同步的数据库的名字log-slave-updates=1 #log更新间隔slave-skip-errors=1 #是跳过错误，继续执行复制操作(可选)binlog_format=MIXED #必须制定日志的类型，这里选择混合日志存储，不然无法建立hive表#重启数据库service mysqld restart 配置从数据配置文件 12345678910#Mysql服务的唯一编号 每个mysql服务Id需唯一server-id = 2read_only=1#只读模式，可以限定普通用户进行数据修改的操作，但不会限定具有super权限的用户（如超级管理员root用户）的数据修改操作。如果想保证super用户也不能写操作，就可以就需要执行给所有的表加读锁的命令 “flush tables with read lock;”replicate-do-db=metastore #需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可replicate-ignore-db=test05 #需要忽略不复制数据库名，如果个数据库，重复设置这个选项即可replicate-rewrite-db = metastore-&gt;apollo # 如果主数据库名字和从数据库名不一样，则使用这个配置，表明将主数据库metastore#复制到从数据库apollo实例下，和replicate-do-db配置不能共存#重启数据库service mysqld restart 设置主数据库复制账号 123456CREATE USER &apos;slave&apos;@&apos;%&apos; IDENTIFIED BY &apos;mysql&apos;;GRANT REPLICATION SLAVE ON *.* TO &apos;slave&apos;@&apos;%&apos;;FLUSH PRIVILEGES;# 查看赋权状态use mysql;select User,authentication_string,Host from user; 查看是否开启日志 1show variables like &apos;log_bin&apos;; 如果开启value值为on Variable_name Value log_bin ON 查看主节点状态1show master status; 结果示例,表示 metastore实例日志文件为mysql-bin.000005，当前日志偏移量为1242284 File Position Binlog_Do_DB mysql-bin.000005 1242284 metastore 操作从数据库 其中change master语句中的master_log_file 为上一步查看的metastore日志文件，master_log_pos为该日志文件的偏移量，这样主数据库中的数据发生变化，偏移量就会增长，从数据库根据偏移量去同步数据 123456# 停止正在进行的slave(如果有，此方法也用于修改slave的值(如果参数不对))stop slave;# 需要主机名，上面步骤的账户密码以及日志文件名字和位置(请根据实际情况自行修改)change master to master_host=&apos;192.168.1.1&apos;, master_user=&apos;slave&apos;, master_password=&apos;mysql&apos;, master_log_file=&apos;mysql-bin.000005&apos;, master_log_pos=1242284;# 启动start slave; 查看状态 12345show slave status;如果发现Slave_IO_Running和Slave_SQL_Running状态为YES则成功Slave_IO_Running负责和主机通讯Slave_SQL_Running负者执行从数据库sql语句Last_Error复制记录上一次同步出错的出错愿意 易错注意点 在配置主数据库配置文件时必须指定 binlog_format类型，不然hive建表会出错 配置从数据配置文件时，replicate-do-db=metastore和replicate-rewrite-db不能共存 当同步主数据库的数据到不同名字的从数据库中时，不可直接用Navicat图形化工具去直接操作数据库，应该写语句去执行，不然会导致同步失败]]></content>
      <categories>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
        <tag>mysql主从搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将hexo发布到github]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%B0%86hexo%E5%8F%91%E5%B8%83%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[创建一个github仓库 创建一个github公有仓库,点击settings如图 选择GitHub Pages选项 设置git分支为，和访问域名 设置hexo部署目录1234567891011打开项目目录下的_config.yml文件修改deploy:属性type 为类型设置为gitbranch设置为master分支repo为你的仓库地址如deploy:type: gitbranch: masterrepo: https:// 参数解释 参数 描述 repo 库（Repository）地址 branch 分支名称。如果不指定，则默认值为 master message 自定义提交信息,非必须 安装部署插件 12进入项目主目录执行$ npm install hexo-deployer-git --save 上传CNAME文件 在项目目录下source中创建一个名字为CNAME的文件，里面填入你所绑定的域名 发布项目至github pages 123$ hexo clean$ hexo g$ hexo d 解决样式丢失问题 此时发布项目至github，css样式会丢失修改以下内容 12345678910打开项目目录下的_config.yml文件修改如下参数url: https://liushprofessor.github.io/liushaohuang.github.io/root: /liushaohuang.github.iopermalink: :year/:month/:day/:title/permalink_defaults:其中url替换为你github的仓库地址(网址)root 为网站的根目录（github对应的仓库名）重新发布解决问题 绑定域名 将域名cname设置为A记录代表ip ，cname代表绑定域名 ,主机记录www代表匹配www.前置网站如www.liushaohuang.cn@ 表示直接解析主域名，匹配liushaohuang.cn的网站 记录类型 主机记录 记录值 A www ip地址 CNAME @ 域名 CNAME WWW 域名]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题的更换]]></title>
    <url>%2F2019%2F08%2F29%2Fhexo%E4%B8%BB%E9%A2%98%E7%9A%84%E6%9B%B4%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[主题主体安装设置 这里以next主题为例，进入hexo项目目录，执行以下命令，从github上下载next主题,并将主题存放在themes目录的next文件夹下 1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 更改主题 12345项目主目录进入主目录，这里以hexo为例$ cd hexo打开该目录下的_config.yml文件将theme属性更改为theme: next 更改主题文字为中文 123同上打开主目录下的_config.yml文件将language属性更改为language: zh-CN 更改主题标题 123同上打开主目录下的_config.yml文件修改title标签为想要的标题title: 标题 主题内部设置 主题内部配置文件为themes/next目录下的_config.yml 更改主题样式 12345在主题配置文件中更改scheme属性来切换不同样式的主题#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 配置菜单找到menu标签以下配置在主要中打开主页，归档页，分类和标签如下图所示 1234567menu: home: / archives: /archives #about: /about categories: /categories tags: /tags #commonweal: /404.html 每个标签的含义为 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 about about: /about 关于页面 commonweal commonweal: /404.html 公益 404 配置标签和分类按钮 现在点击标签和分类按钮是无法使用的，下面进行标签和分类按钮的配置 标签按钮配置 12345678910在hexo项目下执行hexo new page tags执行完成后在source\tags目录下生成index.md文件打开文件在标题中增加 type: &quot;tags&quot;如---title: tagsdate: 2019-08-29 14:35:28type: &quot;tags&quot;--- 配置分类按钮 123456789同上打开工程目录hexo new page categories打开文件在标题中增加 type: &quot;categories&quot;如---title: categoriesdate: 2019-08-29 14:43:25type: &quot;categories&quot;--- 编写博客内容1234567891011121314 执行 hexo new 标题 在source/_posts目录下会出现 标题.md文件 打开文件 给博文添加分类和标签 categories，tags 如下 --- title: 标题 date: 2019-08-29 13:45:29 categories: hexo tags: -hexo -next ---这样这个博文就属于hexo分类，并且其有两个标签hexo和next现在进入首页点击分类和标签按钮即可按分类和标签找到该文章给文章配置图片 方法1 1234567在项目根目下创建images文件夹将图片放入该文件夹如果绑定自己的域名则使用md标签应用图片如![按钮](/images/menu.png)注意：如果使用github提供的域名，由于在github中代码是放在仓库的二级目录中，所以路径需该为![按钮](/仓库名/images/menu.png) 方法2(暂未成功)12345678910更改主目录的_config.yml的文件修改以下配置post_asset_folder: true 当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。 这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后， 你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。在md中使用标签&#123;% asset_img menu.png 标题 %&#125;来引入图片 首页展示文章全文的问题 首页中展示的文章是全文，这样导致首页非常的长，可以使用md语法在文章中加入来控制首页展示的长度]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下hexo搭建]]></title>
    <url>%2F2019%2F08%2F29%2Fhexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[下载nodejs nodejs下载地址下载 安装hexo1npm install -g hexo-cli 构建hexo项目 安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ cd &lt;folder&gt;$ npm install 安装nodejs的依赖到hexo目录下$ hexo init &lt;folder&gt; 初始化hexo项目 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml 网站的配置信息,可以在此配置大部分的参数,详细配置参考官网[配置](https://hexo.io/zh-cn/docs/configuration)├── package.json├── scaffolds 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件├── source 资源文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去| ├── _drafts| └── _posts└── themes 主题目录，主题有自己的_config.yml文件，用来配置主题自己的属性 编译开启web服务 123hexo ghexo s访问http://localhost:4000 即可看见项目 构建时遇到的错误 12在执行hexo init &lt;folder&gt; 命令时 出现ERROR Local hexo not found in错误删除hexo目录下的node_modules文件 然后在hexo工程目录下重新执行npm install 安装nodejs依赖]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
