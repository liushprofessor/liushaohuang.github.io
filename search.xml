<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[领域驱动设计DDD简介]]></title>
    <url>%2F2019%2F09%2F03%2F%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1DDD%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[什么是领域驱动设计 接触领域驱动设计已经有一年多的时间了，其更关注的是解决复杂的软件设计。这期间也拿一些小项目尝试实践过，也看过一些领域驱动的框架如Halo，Cola,在实践过程中发现如果小项目如果采用简化版的领域驱动设计的理念去实践，代码结构也会有明显的改善，在小项目实践过程中更关注的是边界的划分，和不同功能模块代码的解耦，把核心的领域代码和其它代码区分出来，更好的将代码和现实业务结合起来，更好的执行面向对象，在使用领域驱动设计时能让我们从数据库驱动设计的理念中转换出来，在设计时假设计算机内存是无限大，只考虑领域模型，而不考虑数据库模型，从而使代码更贴近业务，我觉得这是领域驱动设计给我带来的感触。就比如架构，架构的本质无非就是把代码的边界区分好，把代码放在该放的地方Eric Evans提出的领域驱动设计是一个很好的解决这部分问题的方法。领域驱动设计，领域代表着行业，你的软件是应用在哪个行业实现什么样的功能，比如你编写了一个财务软件，那么财务行业就是你编写软件的领域，Eric Evans强调软件一定是要由领域专家和领域知识去驱动开发的，因为软件最终是要应用到领域当中，如果绕过这部分内容直接开发软件，那么开发的软件往往无法交付或者无法满足功能，在我认为，软件是现实生活中的映射，在开发第一个版本的时候，可以和领域专家或者领域中的从业人员进行交流业务流程(现实往往只能找到产品经理)，交流一下在没有软件的情况下，线下业务是如何进行的，然后再根据这些流程去建立领域对象，去驱动整体的软件设计。 领域驱动设计的核心概念通用语言 在开发准备之前必须要和领域人员(如果没有，那只能是需求人员)建立好一套通用的开发语言，我曾经在没接触过过领域驱动设计时实现一个功能时并没有和当时对应需求人员建立一套通用的语言，就是产品说的一个名词和你说的名词并不是同一个名词，但是你以为你理解了产品经理的意思，然后就去开发，结果到交付时发现整个理念完全错误，导致最后返工。建立通用语言的过程往往要经过反复沟通后才能得出的，在反复沟通的过程中，抓住一个反复提及的名词，然后确定这个名词代表的含义，反复提及的名词往往就是找到通用语言的关键,在软件建模中也要紧紧围绕这个名词去建模，当你建立完模型后（通常是UML图），把这部分模型拿给领域专家看，因为你这时候的模型就代表着现实的业务，和领域人员确认模型这样设计是否合理。 领域模型贫血型模型 在领域驱动设计中Eric Evans一直不赞成使用贫血型模型，什么是贫血型模型，简单来说就是我们平常建立的java bean对象，只包行一些字段和get，set方法，因为贫血型对象不能很好的展示出领域模型，有一些本该属于领域模型的方法外泄到其它类比如Service类中去了，所有和领域相关的代码都要包含在领域模型中或者领域服务中，举个例子,有一个用户信息模型，一般我们是这样设计和调用的 12345678910111213141516171819202122public class User &#123; private String userId; private String userName; public String getUserId() &#123; return userId; &#125; public void setUserId(String userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125;&#125; 现在我要修改用户的名字那边就要用Service去实现 1234567891011public class UserService &#123; public void changeUserName(String userName,User user)&#123; if(userName!=null)&#123; user.setUserName(userName); &#125; &#125;&#125; 认真考虑一下现实项目中采用上文编写代码所产生的问题 代码不能很好的体现业务changeUserName这个方法应该是属于用户类中的方法，但是现实中该类却放在了调用方的Service中，上文提到了通用语言，在和领域人员沟通时，他们会说到用户修改了用户名，这里作用的主体是用户，只有用户有权利修改自己的用户名，但是体现在代码中却变成了用户把修改用户名的权利交给了调用方，这样的代码并不能很好的反应出业务，也并不是很好的面向对象的模型。 Service上帝类采用上述方法去建模，将会导致service类的代码快速膨胀，久而久之service类负责所有的功能，包括校验，对象持久化，远程调用等待代码，如果在项目开始时还可以接受，但是随着时间的发展，service变成了乱麻，再也没有人能够轻松分清里面的逻辑了。 充血模型 现在我们采用充血模型实现上述代码 12345678910111213public class User &#123; private String userId; private String userName; public void updateUserName(String userName) &#123; if(userName!=null)&#123; this.userName=userName; &#125; &#125;&#125; 现在我们将原本存在Service中的updateUserName方法放到领域模型中，就修改用户名时传入用户名即可完成用户名修改，这完全符合通用语言的用户修改了用户名，并且在修改用户名时候进行了校验，校验本身也是领域对象提供的功能之一，修改用户名的规则应该由领域对象去觉得，而不是由调用方去决定 现在第三方人员修改用户名变的简单了,再也不需要处理本该属于领域对象校验等功能，这样将属于领域的代码和属于调用方的代码很好的分开,代码的层次也更加分明。 12345678public class UserService &#123; public void changeUserName( User user,String userName) &#123; user.changeUserName(userName); &#125; &#125; 实体（Entity） 采用领域驱动设计建模的一个很重要的概念就是实体,书中给的定义是主要由标识定义的对象称为实体(Entity)，现在我们扩展上诉的User对象，在对象里加入一个Address家庭住址对象 12345678 public class User &#123; private String userId; private String userName; private Address address;&#125; 家庭住址对象包含街道名和邮编 123456public class Address &#123; private String street; private String postcode;&#125; 在通用语言中我们会这样描述，我想根据用户id找到对应用户所居住的地址，这里的用户id就是User的标识定义，那么我们认为User它就是一个实体，但是这里的Address并不是实体，它只是一个VO(键值对对象)在用户模型中给地址一个唯一标识定义是没有意义的，因为在用户跟换地址时我直接将整个Address对象替换掉即可，我并不关心地址的状态。 在现实模型中同一个事物可能需要标识为实体，也有可能不需要表示实体，举个例子上述的User为实体，但是换一个场景，订单对象下关联了一个用户对象来表明这个订单是谁买的，在这里我们关注的是订单，把用户作为实体是没有意义的，所以这里订单是实体，User只是一个VO(键值对对象) VO很多对象没有概念上的标识，它们描述了一个事务的某种特性,我们称这些对象为VO 如果将所有对象设计成实体会有什么问题？在书中有一个很好的例子：小孩子总是可以很好的分清楚那副画是自己画的，因为每幅画都有一些标识来区分哪些是自己画的哪些不是，但是如果必须记住哪些线条使用哪只笔画的那情况该有多复杂？上文的User对象的Address就是一个VO，因为我并不关心Address 的状态，它在User对象中只是单纯是键值属性，但是什么情况下地址为实体什么情况下为VO呢？书中举了另外一个例子:在购物系统中需要用地址来标识发货地址，如果室友也从这家店购买了商品，那么意识到他们是否住在同一个地方并不重要（不需要维护地址标识），这里是地址是VO,如果你和舍友同时去申请宽带，那么这里的地址就是实体，因为电信公司需要知道你和你的舍友居住在同一个地方，这样他们只要上门一次即可。 另一个VO的重要特性是VO是可以整个被替换的，其没有包含副作用的方法，举个例子上文User关联的Address对象,将Address对象传给其它人调用里面的方法并不会对User类产生影响，因此可以放心的将VO传给任何人调用，在设计中尽量将对象设计成VO来减少系统的复杂性，大举个例子，上文中User如果修改Address如果Address的话我们直接在User对象中整个替换Address对象即可完成地址的修改，但是如果地址为实体的话，那么我们必须用地址标识还原出Address对象，然后将地址对象的属性做修改 领域服务 在书中是给领域服务这样定义的：在领域中的某个操作过程或转换过程不是实体或者值对象（VO）的职责时，我们应该将操作放在一个单独的接口中，即领域服务，请确保领域服务和通用语言是一致的，并且保证它是无状态的。 在现实代码中我更喜欢把领域当成客户端调用的代码，领域模型由建模人员编写完代码，然后将这部门代码交给客户端人员去调用，领域建模人员必须保证客户端代码的易用性，如果有些方法并不适合在领域模型中，那么可以将其放在领域服务中，这样可以对客户端人员屏蔽领域细节，例如用户登录时可能涉及到鉴权，鉴权部分可能是另一个模型对象，如果我们不使用领域服务将这些工作全部交给客户端人员去做的话，那么客户端的程序员就必须知道业务的逻辑，要知道原来登录要先鉴权，他先去执行鉴权代码再去执行验证用户密码的代码，这样就导致领域信息暴露，更好的做法应该是用领域服务将鉴权和验证用户信息的方法放在领域服务中，然后再对外暴露一个登陆验证的服务，这样就对客户端程序员屏蔽了领域信息，他只需要调用一个登陆的领域服务即可，不用去关心领域里的逻辑,关于领域服务的具体实践和分包我讲在后续小项目领域驱动实践中介绍。 聚合 在日常开发中将实体和VO进行聚合组成聚合对象是非常普遍的，我们将这些对象称之为聚合，聚合对象都有一个主体我们称之为聚合跟，在使用聚合时对客户端程序员暴露的都应该是聚合根，而不是聚合根下的对象，举例 123456789101112 public class User &#123; private String userId; private String userName; private Address address; public void saveAddress(Address address)&#123; this.address=address; &#125;&#125; 上文中的User对象包就是一个聚合它包含了用户的用户名，用户id属性，也包含了一个地址VO，我们在对外提供领域模型给客户端程序员时我们只能建User对象中的方法,比如上文的saveAddress保存地址方法，而不是将一个个调用Address对象中的get set方法。在实际设计过程中有时候由于聚合包含太多的VO和实体导致聚合过于庞大，我们可以将聚合进行拆分，具体的实践方法我讲在后续小项目领域驱动实践的文章中表述。 资源库（Repository） Repository对领域模型屏蔽了持久化的代码，因为现实软件设计中领域对象不可能全部都存留在内存中，当一个领域对象从创建开始我们就认为其已开始其的生命周期，即使后续将这个领域对象存储在数据库等持久化的对象中我们仍然认为其仍处于生命周期内，直到我们在数据库中将其删除我们才认为一个领域对象生命的结束，资源库就是为了在领域对象存储在数据库或者其它一些持久化组件中时将其还原成领域对象而设计的，比如如下代码 1234567891011121314public class UserRepository &#123; public void addUser(User user)&#123; //持久化代码 &#125; public User findUserById(String userId)&#123; //模拟从数据库中生成对象 User user=new User(); return user; &#125;&#125; 在客户端服务调用完领域服务生成领域对象后，客户端将领域对象传入到资源库中将其持久化(addUser)，同样，资源库也可以根据各种条件去还原一个领域对象（findUserById） 架构设计（六边形架构） 在采用领域驱动设计时我采用的是六边形架构如图 下面是我在网上摘抄的对六边形架构的简介 六边形架构还是一种分层架构，如上图所示，它被分为了三层：端口适配器、应用层与领域层。而端口又可以分为输入端口和输出端口。 输入端口用于系统提供服务时暴露API接口，接受外部客户系统的输入，并客户系统的输入转化为程序内部所能理解的输入。系统作为服务提供者是对外的接入层可以看成是输入端口。 输出端口为系统获取外部服务提供支持，如获取持久化状态、对结果进行持久化，或者发布领域状态的变更通知（如领域事件）。系统作为服务的消费者获取服务是对外的接口（数据库、缓存、消息队列、RPC调用）等都可以看成是输入端口。 应用层定义系统可以完成的工作，很薄的一层。它并不处理业务逻辑通过协调领域对象或领域服务完成业务逻辑，并通过输入端口输出结果。也可以在这一层进行事物管理。 领域层负责表示业务概念、规则与状态，属于业务的核心。 应用层与领域层的不变性可以保证核心领域不受外部的干扰，而端口的可替换性可以很方便的对接不用的外部系统 我在这里对以上的解释说明下 输入端口在上图中对应适配器A,B,C,D比如在http服务中其对应的就是Controller层，用Spring的话就是SpringMVC框架，适配器完成了http对应用用程序的转化，因为应用层提供了固定的API来满足各种渠道的调用，比如现在我要增加一个人RPC调用，我只要根据应用层所提供的API写一个转换器将应用层的API转化成RPC调用的方法即可，图中领域模型作为为核心最稳定的内容放在了六边形的中央，其它所有的组件都必须依赖领域模型，这符合了领域驱动的模型。最后是输出端口，我们将持久化的代码放入这里（资源库Repository）下面给出我们架构设计的依赖结构* 输出层 -&gt; 应用程序(APP) -&gt; 资源库（Repository）-&gt; 领域层 实际中领域层中的领域服务有可能会调用到资源库（Repository），但是我们又不能让领域层去依赖资源库层，因为领域层是项目的核心，应该是最稳定的部分，会被大量的组件依赖，而资源库层相对领域层更加不稳定（比如数据库中新增一个字段等），那么我们这里就要用依赖倒置技术使资源库依赖领域层，具体实践放在小项目领域驱动实践中去讲解*]]></content>
      <categories>
        <category>领域驱动设计(DDD)</category>
      </categories>
      <tags>
        <tag>领域驱动设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[greenplum集群安装]]></title>
    <url>%2F2019%2F09%2F02%2Fgreenplum%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Greenplum集群搭建 关闭所有主机防火墙12systemctl stop firewalld.servicesystemctl disable firewalld.service 关闭SELINUX 12vi /etc/selinux/config将属性 SELINUX 改为 disabled 系统设置设置hostname12345vi /etc/hosts添加各个主机的hostname如:192.168.171.75 master192.168.171.76 node1192.168.171.77 node2 设置系统参数至sysctl.conf12345678910111213141516171819202122232425262728vi /etc/sysctl.conf在文件中添加以下代码kernel.shmmax = 500000000kernel.shmmni = 4096kernel.shmall = 4000000000kernel.sem = 500 2048000 200 40960kernel.sysrq = 1kernel.core_uses_pid = 1kernel.msgmnb = 65536kernel.msgmax = 65536kernel.msgmni = 2048net.ipv4.tcp_syncookies = 1net.ipv4.conf.default.accept_source_route = 0net.ipv4.tcp_max_syn_backlog = 4096net.ipv4.conf.all.arp_filter = 1net.ipv4.ip_local_port_range = 10000 65535net.core.netdev_max_backlog = 10000net.core.rmem_max = 2097152net.core.wmem_max = 2097152vm.overcommit_memory = 2vm.swappiness = 10vm.zone_reclaim_mode = 0vm.dirty_expire_centisecs = 500vm.dirty_writeback_centisecs = 100vm.dirty_background_ratio = 0vm.dirty_ratio = 0vm.dirty_background_bytes = 1610612736vm.dirty_bytes = 4294967296 在/etc/security/limits.conf中修改以下参数123456vi /etc/security/limits.conf修改以下参数* soft nofile 65536* hard nofile 65536* soft nproc 131072* hard nproc 131072 同步集群时间1234567891011在所有主机上安装ntpyum install -y ntp添加如下内容server 127.127.1.0fudge 127.127.1.0 stratum 10保存退出，然后启动ntp 服务并设为开机启动：systemctl start ntpdsystemctl enable ntpd在集群其他节点安装ntp 服务，并将ntp 服务server 指向主节点echo &quot;server &lt;ip&gt; iburst&quot; &gt; /etc/ntp.conf&lt;ip&gt; 替换为主节点ip 地址 免密登录1234567891011121314151617181920用root用户登录所有主机编辑文件 /etc/ssh/sshd_config将以下两行前面的#号去掉，保存RSAAuthentication yesPubkeyAuthentication yes在所有主机上执行以下命令ssh-keygen -t rsa按四下回车得到public key在所有主机上执行以下命令，将所有主机的public key 拷贝到主节点上ssh-copy-id root@&lt;hostname&gt;&lt;hostname&gt;更换为主节点主机的主机名在主节点机器上通过scp 命令将文件 /root/.ssh/authorized_keys 发送到所有其他节点主机的 /root/.ssh/ 目录下：scp /root/.ssh/authorized_keys root@&lt;hostname&gt;:/root/.ssh/重启所有主机的sshd 服务systemctl restart sshd.servicesystemctl enable sshd.service验证免密码登陆 ：ssh &lt;hostname&gt;&lt;hostname&gt; 更换为主机名。 在主节点安准Greenplum123456rpm -Uvh ./greenplum-db-&lt;version&gt;-&lt;platform&gt;.rpm数据库软件安装在/usr/local/greenplum-db-&lt;version&gt;目录下修改目录权限为gpadmin所有chown -R gpadmin /usr/local/greenplum*chgrp -R gpadmin /usr/local/greenplum* 在集群中安装Greenplum1234567891011121314151617181920su -切换至root用户touch hostfile_exkeys创建一个hostfile_exkeys文件将所有主机hostname放入其中（主机包含所有master, standby master,segments）如mdwmdw-1mdw-2smdwsmdw-1smdw-2sdw1sdw1-1sdw1-2sdw2sdw2-1sdw2-2sdw3sdw3-1sdw3-2 12345创建groupadd账号和groupadd组groupadd gpadminuseradd gpadmin -g gpadminpasswd gpadmin 1234567安装Greenplum rpm包rpm -Uvh ./greenplum-db-&lt;version&gt;-&lt;platform&gt;.rpm数据库默认安装在/usr/local/greenplum-db-&lt;version&gt;目录下更改安装目录权限为gpadmin用户所有 chown -R gpadmin /usr/local/greenplum* chgrp -R gpadmin /usr/local/greenplum* 12345678910111213141516171819202122232425262728将安装分发给集群其它主机执行创建一个空文件touch hostfile_exkeys将集群所有hostname写入文件，如: mdw mdw-1 mdw-2 smdw smdw-1 smdw-2 sdw1 sdw1-1 sdw1-2 sdw2 sdw2-1 sdw2-2 sdw3 sdw3-1 sdw3-2执行以下命令在集群中安装数据库gpseginstall -f hostfile_exkeys确认集权是否安装成功su - gpadminsource /usr/local/greenplum-db/greenplum_path.shgpssh -f hostfile_exkeys -e ls -l $GPHOME如果可以看到集群信息则安装成功 创建数据目录12345678在主节点中创建目录，目录地址根据实际情况更改mkdir -p /data/master改变目录所有者chown gpadmin /data/master如果有副主节点，执行以下命令在副主节点中创建相同目录，smdw为副主节点hostnamesource /usr/local/greenplum-db/greenplum_path.shgpssh -h smdw -e &apos;mkdir -p /data/master&apos;gpssh -h smdw -e &apos;chown gpadmin /data/master&apos; 创建段节点（数据节点）目录123456创建空文件touch hostfile_gpssh_segonly将所有段节点（数据节点）的hostname填入如:sdw1sdw2sdw3 用gpssh命令在段节点(数据节点)创建目录和更改其权限1234source /usr/local/greenplum-db/greenplum_path.shgpssh -f hostfile_gpssh_segonly -e &apos;mkdir -p /data/primary&apos;gpssh -f hostfile_gpssh_segonly -e &apos;mkdir -p /data/mirror&apos;gpssh -f hostfile_gpssh_segonly -e &apos;chown -R gpadmin /data/*&apos; 配置数据库123456789101112131415161718192021222324252627282930313233343536切换至gpadminsu - gpadmincp $GPHOME/docs/cli_help/gpconfigs/gpinitsystem_config /home/gpadmin/gpconfigs/gpinitsystem_config备份配置文件到新目录下修改备份文件gpinitsystem_config，修改以下参数DATA_DIRECTORY（将创建主段数据目录的文件系统位置,有几个DATA_DIRECTORY, 每个节点上便会启动几个segments#### 指定Primary Segment的数据目录, DATA_DIRECTORY参数指定每个Segment主机配置多少个Instance。如果#### 在host文件中为每个Segment主机列出了多个网口，这些Instance将平均分布到所有列出的网口上。#### 这里的案例，hosts里有2个segment，sdw1，sdw2俩主机，都是单网卡段的数量划分要根据服务器的cpu，网卡，磁盘因数划分最好达到share nothing的效果，每个段都有独自的处理器，磁盘或者网卡）MASTER_HOSTNAME(主节点hostname)MASTER_DIRECTORY（将创建主数据目录的文件系统位置）MIRROR_DATA_DIRECTORY（建立节点的镜像mirror节点的地址，镜像的数量必须和DATA_DIRECTORY的数量一致）详细参数说明查阅https://gpdb.docs.pivotal.io/5190/utility_guide/admin_utilities/gpinitsystem.html----------------------------------------------------------------ARRAY_NAME=&quot;Greenplum Data Platform&quot;SEG_PREFIX=gpsegPORT_BASE=40000declare -a DATA_DIRECTORY=(/data/primary)MASTER_HOSTNAME=mdwMASTER_DIRECTORY=/data/masterMASTER_PORT=5432TRUSTED SHELL=sshCHECK_POINT_SEGMENTS=8ENCODING=UNICODE...MIRROR_PORT_BASE=7000REPLICATION_PORT_BASE=8000MIRROR_REPLICATION_PORT_BASE=9000declare -a MIRROR_DATA_DIRECTORY=(/data1/mirror /data1/mirror /data1/mirror /data2/mirror /data2/mirror /data2/mirror)----------------------------------------------------------------- 运行初始化脚本1234567891011121314151617181920 创建文件里面所有段节点（数据节点）hostname touch vi hostfile_gpinitsystem 数据如: sdw1-1 sdw1-2 sdw2-1 sdw2-2 sdw3-1 sdw3-2 sdw4-1 sdw4-2执行以下命令，gpconfigs/gpinitsystem_config为上面更改的配置文件，hostfile_gpinitsystem为所有的段节点hostname，standby_master_hostname为副主节点的hostnamecd ~gpinitsystem -c gpconfigs/gpinitsystem_config -h gpconfigs/hostfile_gpinitsystem \ -s standby_master_hostname -S 当出现Continue with Greenplum creation? Yy/Nn时 输入y回车 出现以下提示表示安装成功 Greenplum Database instance successfully created. 在主节点和备份主节点设置环境变量12345678su - gpadminvi ~/.bashrc添加以下内容，MASTER_DATA_DIRECTORY为实际master目录路径source /usr/local/greenplum-db/greenplum_path.shexport MASTER_DATA_DIRECTORY=/data/master/gpseg-1(注意)如果是RHEL 7 or CentOS 7系统，需要在.bashrc文件的末尾添加如下内容:export LD_PRELOAD=/lib64/libz.so.1 ps至此安装完成 设置账号123456789登录master节点运行psql修改管理员密码alter role gpadmin with password &apos;hzt_2019&apos;;输入\q退出客户端设置账号访问权限,路径根据实际路径填写vi /data/master/gpseg-1添加以下代码，设置gpadmin可远程登录host all gpadmin 0.0.0.0/0 trust]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>greenplum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓慢维度的设计和处理]]></title>
    <url>%2F2019%2F09%2F02%2F%E7%BC%93%E6%85%A2%E7%BB%B4%E5%BA%A6%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于缓慢维度变化的简介 在数据仓库设计中理想状态下维度是不会变化的，但是事与愿违，大部分业务系统中的维度是会发生变化的，那么如何去处理这些变化的维度就是本文关注的内容，举个例子如下企业组织架构维度表 ID_ 企业名 部门名 组名 1 微软 研发部 开发一组 如果有一天上表中的部门名发生变化怎么办?根据Kimball的数据仓库工具箱，我们把处理缓慢维度的方法分为7种类型，其为类型1至类型7 类型1:重写 顾名思义，就是将维度表中的字段简单的替换，如上表中如果采用类型1的话，如果部门后续由研发部变成技术部，那么维度表将变成下表，部门维度表和部门人数事实表做关联 ID_ 企业名 部门名 组名 1 微软 技术部 开发一组 部门人数事实表 ID_ 部门ID外键 人数 1 1 10 类型1的优劣势 有点是简单易于实现，仅需重写维度表中的属性值而不需要去更改事实表，但是无法保留历史值，如果业务中存在对维度的历史值进行分析，那么就无法采用该类型，举例：采用类型1将部门名改成技术部后，现在需要分析在部门叫研发部时，研发部下有多少人?那么如果采用类型1将无从下手，因为维度表中没有保存历史维度数据,而部门人数事实表中的数据是用部门ID去与其关联的。但是实际中如果采用类似hive无法执行update语句的数据仓库工具去建设的话，那么只能重新全量生成维度表 类型2：增加新行 类型2是最常用的处理缓慢维度的办法,如果采用此设计方式则在部门名变更为技术部时维度表和事实表如下 ID_ 企业名 部门名 组名 行有效日期 行失效日期 是否生效 1 微软 研发部 开发一组 2011-1-1 2019-9-1 no 2 微软 技术部 开发一组 2019-9-2 9999-1-1 yes 部门人数事实表 ID_ 部门ID外键 人数 1 1 10 2 2 100 在事实表中原来旧的数据仍然和研发部关联，但是新增的数据已经和新的维度（技术部）做关联。这样数据就保留了历史变化的信息，如果需求中存在对历史维度进行分析的话可以采用此类型应对维度缓慢维度变化。 类型3：新增新列 采用维度2去处理维度变化时存在一个缺点，如果需求需要将新的属性值和旧的属性值做关联分析，那么采用类型2将很难实现，因为类型2并没有记录维度变化的关联关系，如果存在这方面需求则可以采用类型3处理，事实表通过代理键ID关联维度表(维度表在创建时自己生产的id，不是业务方提供的ID)但实际中类型3不经常使用 如： ID_ 企业名 当前部门名 之前部门名 组名 1 微软 技术部 研发部 开发一组 部门人数事实表 ID_ 部门ID外键 人数 1 1 10 类型4：微型维度 其解决问题的场景为应对维度表中存在大量数据（几百万），且一些属性快速变化。因为当维度表中存在大量的数据，特别是维度中某些信息还是易变时，我们不希望已经存在几百万的维度表中新增数据（采用类型2），因为这样会使维度表发生膨胀，实际情况中维度表中的数据应该远远小于事实表，那么类型3就派上用场，还是引用上诉两张表，假设现在部门维度有几十万个部门，且组名经常发生变化（即使不太可能），那么我们将才用下面设计 部门表 ID_ 企业名 部门名 1 微软 研发部 组名表 ID_ 组名 1 开发一组 1 开发二组 部门人数事实表 ID_ 部门ID外键 组名外键 人数 1 1 1 10 2 1 2 100 部门表和组名表不再使用星型维度直接做关联，而是在事实表中新建外键来关联部门和组 类型5：微型维度与类型1支架表 之所以称之为类型5是因为其是类型4和类型1的结合 4+1=5，该技术实现为在主维度中用一个外键id和一个微型维度做关联，这样能避免微型维度发生变化时更新主维度的每行的信息，且如果客户需求需要在不关联事实表的情况下完成维度的过滤分析等类型5是很好的处理方法，举例 商店维度表 ID_ 商店名 地区ID 1 一号门店 1 地区维度表 地区ID 省 市 县 1 福建省 福州市 闽清县 如果不采用类型5的话维度表结构为 ID_ 商店名 省 市 县 1 一号门店 福建省 福州市 闽清县 2 二号门店 福建省 福州市 闽清县 那么有一条闽清县更改了名字变成闽清市，如果不采用类型5支架表的话那么将要更改所有商店维度表中有关闽清县的记录，将其改成闽清市，如果你在很多事实表中都使用了地区信息，那就需要更改所有有关地区的维度，这是无法忍受的，但是如果采用类型5则只需要更改地区类型的属性即可完成所有有关地区维度信息的修改。 类型6 类型6为 类型2,3,1的组合（2+3+1=6），回顾类型3，当为了记录维度变化的历史先后关系时我们采用类型3，但是类型3也有一个缺点就是它只记录当前的变化，和上一次的变化，类型6解决了这个问题，其维度表如： ID_ 企业名 当前部门名 之前部门名 组名 生效日期 结束日期 当前是否生效 1 微软 技术部 研发部 开发一组 2011-1-1 2019-9-1 no 2 微软 技术部2 技术部 开发一组 2011-1-1 9999-1-1 yes 部门人数事实表 ID_ 部门ID外键 人数 1 1 10 尽管该技术具有某种诱惑力，但是加大了系统的复杂度，考虑任务是否有这种需求才使用这种方法。 类型7 当需要分析维度表的当前和历史场景的时候可以使用类型7，其运用事实表关联类型2和基于类型2的维度表创建一个当前部门的视图来实现，如下 部门维度 ID_ 部门编码 企业名 当前部门名 生效日期 结束日期 当前是否生效 1 code1 微软 研发部 2011-1-1 2019-9-1 no 2 code1 微软 技术部 2011-1-1 9999-1-1 yes 当前部门视图（可以根据部门问题创建一个当前部门视图 比如:select * from 部门维度 where 当前是否生效=’yes’） 部门编码 部门ID 当前部门名 code1 2 技术部 code1 3 人力资源部 部门人数事实表 ID_ 部门ID外键 部门编码 人数 1 1 code1 10 2 2 code1 10 这样通过事实表中存在，部门ID外键和部门编码就可以分析历史部门数据和当前部门数据所存在的关系 杂项目维度 在建模过程中通常会遇到大量五花八门的指标和描述，它们包行小的范围离散值处理这些离散值有一下几种方法 忽略这些标志和指标,如果这些描述具有业务价值则不能采用这种方式 在事实表中保存这些表示，尽量不要在事实表中保存这些描述，这些描述可能使事实表的列发生膨胀 将每个标志和指标放入各自的维度，如果事实表的外键在合理范围内（不超过20个），则在事实表中加入不同的外键是可接受的。 杂项维度,如下 在交易事实表中存在以下杂项描述 支付方式:CASH,CREDIT购买渠道:ONLINE,OFFLINE对应事实表中一共存在以下4中组合方式（2的二次方），数据为 支付方式 购买渠道 CASH ONLINE CASH OFFLINE CREDIT ONLINE CREDIT OFFLINE 那么与其建这些杂项目反正事实表中，或者维度数目已经较大的情况下，我们可以创建一个杂项维度,将这些杂项的所有可能罗列出来如 ID 支付方式 购买渠道 1 CASH ONLINE 2 CASH OFFLINE 3 CREDIT ONLINE 4 CREDIT OFFLINE 现在在事实表中的数据为 ID_ 杂项外键 金额 1 2 100 2 1 1000 不同粒度的事务事实（表头模式） 实践中应该避免这么模式，应该保证事实表中的粒度和维度是一样的 比如存在订单详细事实表 ID_ 订单ID 商品外键 金额 1 order1 1 1000 2 order1 2 888 订单维度表 ID_ 订单描述 order1 订单1信息 order1 订单2信息 这样的设计存在一个问题，订单详情事实表中的粒度是订单的每个商品，但是却关联了订单维度，这两个关联存在不同的粒度，应该尽量避免这种情况，更好的做法应该是再新建一个关于订单的事实表，在订单明细表中将订单id做为退化维度（只是单纯的记录一下订单id，为了方便分析） 多币种 最常见的分析需求是订单事务以当地交易币种表示，在构建订单事实表时应该包含2种货币信息事实，一种是当地货币，一种是公司采用的标准统计货币，比如公司在日本销售的货物以日元结算，公司财报中的统计标准为美元，那么在订单事实表中应该包行2种货币，一种是日元，一种是公司的标准货币美元。]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>维度</tag>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据仓库维度建模概述]]></title>
    <url>%2F2019%2F08%2F31%2F%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是维度 简单的来说维度就是用于分析数据仓库中的事实的描述（关于事实下文讲解）.举个例子在数据库中有两张表，订单明细表和商品表 订单明细表 ID_ ORDER_ID PRODUCT_ID_ quantity 1 1 1 10 商品表 ID_ PRODUCT_NAME 1 华为手机 这两张表中订单明细表使用商品表中的id与之关联，订单明细表为事实表记录了订单明细的事实，商品表就为维度表，因为商品表描述了订单明细表，我们通过商品表中的维度信息去分析订单明细表中的数据，用需求文字来描述就是我想查购买了华为手机的所有订单明细，转换成SQL语句为 1select * from 订单表 t1 inner join 商品表 t2 on t1.PRODUCT_ID_=t2.ID_ where t2.PRODUCT_NAME=&apos;华为手机&apos; 什么是事实 事实一般只是一些单纯的数字，如上文订单表中的数量，它仅仅是订单中的一个度量，没有什么文字描述，文字描述都存在维度表中,通过维度表去分析事实表。 什么是粒度 事实表中的存储数据都要有相同的粒度,粒度用于确定某一事实表中的行表示什么,例如上文订单明细表中的粒度是到商品,不是订单，因为表中有一个产品id，如果该表去掉PRODUCT_ID_和quantity那么该事实表中的粒度就为订单（一个订单中可能包含很多商品）,所有的事实表中的数据都应该有相同的粒度，同样维度表中的关联也需要和事实表中的粒度做对应，就好比上文的订单明细表中最好不要出现订单的维度，比如订单类型等信息. 设计维度的过程选择业务过程 业务过程一般存储在业务系统的关系型数据库中，我们必须根据需求选取对应业务表中的数据，如我需要建立订单为主题的数据集市，则我需要抽取业务系统中关于订单的数据 声明粒度 最好要包行最低粒度，如上文中建立一张订单明细表，而不是只建立订单表，因为细粒度可以根据维度上卷得到粗粒度的数据，反之则不能。 描述维度 维度提供业务的描述，比如谁，什么，何处，何时等。维度表为数据仓库中的灵魂，是数据仓库中最重要的部分，维度描述越丰富，则数据仓库中所挖掘的信息越多。 确认事实 事实涉及业务过程事件的度量,基本上都是以数量值表示，一个事实表中的所有粒度需要保持一致。 数据仓库的分层 目前项目中采用了4层架构分别为 ods贴源层，ods层中存放了业务表中原封不动的数据 dwd数据清洗层,dwd为了清理ods层中的数据 dws主题层,此层获取dwd中的数据根据不同的主题组成不同粒度的事实表和维度供业务方调用 ads层，此层一般为一些汇总数据供前端展示时调用 不同数据集市间的数据划分可以考虑在同一个数据实例中根据表名建立各个数据集市中的4个不同的层，根据表名区分不同数据集市中的表，也可以根据不同数据集市建立不同的数据库实例来存储上文4个层的表，目前由于建立的数据集市较少为了方便才用同一个数据库实例。 数据的仓库架构总线型架构 Kimball总线架构为，在项目开始时，由架构师设计通用维度，这个维度称为总线，设计完成总线后，将总线维度分发给各个数据集市的开发人员同步去开发，比如订单数据集市，库存数据集市。各个集市中的维度根据总线去做扩展，各个数据集市的数据再ads层之前是不做交互的，如果要跨域多个数据集市去分析数据，那么就用通用维度（总线）去连接各个数据集市中的不同事实表去分析数据。 维度表设计 现在维度表的设计一般分为星型结构和雪花型结构 星型结构，采用宽表和冗余的形式存储维度，维度的父子关系都在一张表中关联，不通过外键关联，如下面时间表: id 年 月 日 20190101 2019 01 01 20190102 2019 01 02 那么如果我想查询实时表中id为20190101的数据对应的月份是几月，那么我们可以使用id去时间维度去查找对应的月份 雪花结构,雪花结构的设计更多的用于关系型数据库，上图的时间维度用雪花型表示为年表 id 年 2019 2019 2018 2018 月表 id 月份 1 01 2 02 年月关系表 id year_id month_id 1 2019 1 2 2019 2 两种设计的优缺星型结构：对查找的效率和难度来说更加高效简单，但是存储了大量冗余数据，而且不够灵活不方便修改，如果存在大量描述字段的话，那么冗余结构相比雪花结构使用更大的存储空间雪花结构：数据更加灵活，比如更改维度表的信息不需要更改整个维度的信息，比如上文我要更改月份里面的字段我只需要更改月表中的信息即可，不需要更改整张维度表，但是查询更加麻烦和慢。其实归根到底就是范式设计和非范式设计，在数仓中大多数情况下应该使用星型结构，因为数仓关注的是查询，用存储空间换取查询数据的方便是值得的，至于对于星型结构存在维度变更的问题，我们将在另一篇文章，维度缓慢变化中说明]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>维度</tag>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hive mysql元数据表单的主从备份]]></title>
    <url>%2F2019%2F08%2F30%2Fhive-mysql%E5%85%83%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%8D%95%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[hive元数据库和使用介绍 hive 会将表的元数据信息存储在数据库中，这里采用mysql作为元数据库存储hive的元数据 元数据表中记录着很多hive中有用的信息，比如数据库实例，表，表结构，还有表数据的条数 表数据条数只有在hive为内部表时的统计是准确的，如果建立的表为外部表 (external)则需要执行统计语句才能得到准确结果 1ANALYZE TABLE tablename COMPUTE STATISTICS; 使用元数据表中的统计数据可以很简单快捷的得到hive的元数据，比如表的数量，和数据量 mysql主从介绍 mysql主从时利用mysql的日志来完成主从的，所以在做主从设置时，先要保证主数据库和从数据库数据的一致 迁移数据 如果主数据库中已经在做主从时已经存在数据那么，先将主数据库中数据复制到从数据库中，从而保证主数据库和从数据库数据的一致 配置主数据库配置文件 1234567891011vi /etc/my.cnf#将以下信息填入server-id = 1 #Mysql服务的唯一编号 每个mysql服务Id需唯一log-bin=mysql-bin #logbin的名字binlog-do-db=metastore #需要同步的数据库的名字，如果是多个数据库存在多条binlog-ignore-db=test01 #不需要同步的数据库的名字log-slave-updates=1 #log更新间隔slave-skip-errors=1 #是跳过错误，继续执行复制操作(可选)binlog_format=MIXED #必须制定日志的类型，这里选择混合日志存储，不然无法建立hive表#重启数据库service mysqld restart 配置从数据配置文件 12345678910#Mysql服务的唯一编号 每个mysql服务Id需唯一server-id = 2read_only=1#只读模式，可以限定普通用户进行数据修改的操作，但不会限定具有super权限的用户（如超级管理员root用户）的数据修改操作。如果想保证super用户也不能写操作，就可以就需要执行给所有的表加读锁的命令 “flush tables with read lock;”replicate-do-db=metastore #需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可replicate-ignore-db=test05 #需要忽略不复制数据库名，如果个数据库，重复设置这个选项即可replicate-rewrite-db = metastore-&gt;apollo # 如果主数据库名字和从数据库名不一样，则使用这个配置，表明将主数据库metastore#复制到从数据库apollo实例下，和replicate-do-db配置不能共存#重启数据库service mysqld restart 设置主数据库复制账号 123456CREATE USER &apos;slave&apos;@&apos;%&apos; IDENTIFIED BY &apos;mysql&apos;;GRANT REPLICATION SLAVE ON *.* TO &apos;slave&apos;@&apos;%&apos;;FLUSH PRIVILEGES;# 查看赋权状态use mysql;select User,authentication_string,Host from user; 查看是否开启日志 1show variables like &apos;log_bin&apos;; 如果开启value值为on Variable_name Value log_bin ON 查看主节点状态1show master status; 结果示例,表示 metastore实例日志文件为mysql-bin.000005，当前日志偏移量为1242284 File Position Binlog_Do_DB mysql-bin.000005 1242284 metastore 操作从数据库 其中change master语句中的master_log_file 为上一步查看的metastore日志文件，master_log_pos为该日志文件的偏移量，这样主数据库中的数据发生变化，偏移量就会增长，从数据库根据偏移量去同步数据 123456# 停止正在进行的slave(如果有，此方法也用于修改slave的值(如果参数不对))stop slave;# 需要主机名，上面步骤的账户密码以及日志文件名字和位置(请根据实际情况自行修改)change master to master_host=&apos;192.168.1.1&apos;, master_user=&apos;slave&apos;, master_password=&apos;mysql&apos;, master_log_file=&apos;mysql-bin.000005&apos;, master_log_pos=1242284;# 启动start slave; 查看状态 12345show slave status;如果发现Slave_IO_Running和Slave_SQL_Running状态为YES则成功Slave_IO_Running负责和主机通讯Slave_SQL_Running负者执行从数据库sql语句Last_Error复制记录上一次同步出错的出错愿意 易错注意点 在配置主数据库配置文件时必须指定 binlog_format类型，不然hive建表会出错 配置从数据配置文件时，replicate-do-db=metastore和replicate-rewrite-db不能共存 当同步主数据库的数据到不同名字的从数据库中时，不可直接用Navicat图形化工具去直接操作数据库，应该写语句去执行，不然会导致同步失败]]></content>
      <categories>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
        <tag>mysql主从搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将hexo发布到github]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%B0%86hexo%E5%8F%91%E5%B8%83%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[创建一个github仓库 创建一个github公有仓库,点击settings如图 选择GitHub Pages选项 设置git分支为，和访问域名 设置hexo部署目录1234567891011打开项目目录下的_config.yml文件修改deploy:属性type 为类型设置为gitbranch设置为master分支repo为你的仓库地址如deploy:type: gitbranch: masterrepo: https:// 参数解释 参数 描述 repo 库（Repository）地址 branch 分支名称。如果不指定，则默认值为 master message 自定义提交信息,非必须 安装部署插件 12进入项目主目录执行$ npm install hexo-deployer-git --save 上传CNAME文件 在项目目录下source中创建一个名字为CNAME的文件，里面填入你所绑定的域名 发布项目至github pages 123$ hexo clean$ hexo g$ hexo d 解决样式丢失问题 此时发布项目至github，css样式会丢失修改以下内容 12345678910打开项目目录下的_config.yml文件修改如下参数url: https://liushprofessor.github.io/liushaohuang.github.io/root: /liushaohuang.github.iopermalink: :year/:month/:day/:title/permalink_defaults:其中url替换为你github的仓库地址(网址)root 为网站的根目录（github对应的仓库名）重新发布解决问题 绑定域名 将域名cname设置为A记录代表ip ，cname代表绑定域名 ,主机记录www代表匹配www.前置网站如www.liushaohuang.cn@ 表示直接解析主域名，匹配liushaohuang.cn的网站 记录类型 主机记录 记录值 A www ip地址 CNAME @ 域名 CNAME WWW 域名]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题的更换]]></title>
    <url>%2F2019%2F08%2F29%2Fhexo%E4%B8%BB%E9%A2%98%E7%9A%84%E6%9B%B4%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[主题主体安装设置 这里以next主题为例，进入hexo项目目录，执行以下命令，从github上下载next主题,并将主题存放在themes目录的next文件夹下 1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 更改主题 12345项目主目录进入主目录，这里以hexo为例$ cd hexo打开该目录下的_config.yml文件将theme属性更改为theme: next 更改主题文字为中文 123同上打开主目录下的_config.yml文件将language属性更改为language: zh-CN 更改主题标题 123同上打开主目录下的_config.yml文件修改title标签为想要的标题title: 标题 主题内部设置 主题内部配置文件为themes/next目录下的_config.yml 更改主题样式 12345在主题配置文件中更改scheme属性来切换不同样式的主题#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 配置菜单找到menu标签以下配置在主要中打开主页，归档页，分类和标签如下图所示 1234567menu: home: / archives: /archives #about: /about categories: /categories tags: /tags #commonweal: /404.html 每个标签的含义为 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 about about: /about 关于页面 commonweal commonweal: /404.html 公益 404 配置标签和分类按钮 现在点击标签和分类按钮是无法使用的，下面进行标签和分类按钮的配置 标签按钮配置 12345678910在hexo项目下执行hexo new page tags执行完成后在source\tags目录下生成index.md文件打开文件在标题中增加 type: &quot;tags&quot;如---title: tagsdate: 2019-08-29 14:35:28type: &quot;tags&quot;--- 配置分类按钮 123456789同上打开工程目录hexo new page categories打开文件在标题中增加 type: &quot;categories&quot;如---title: categoriesdate: 2019-08-29 14:43:25type: &quot;categories&quot;--- 编写博客内容1234567891011121314 执行 hexo new 标题 在source/_posts目录下会出现 标题.md文件 打开文件 给博文添加分类和标签 categories，tags 如下 --- title: 标题 date: 2019-08-29 13:45:29 categories: hexo tags: -hexo -next ---这样这个博文就属于hexo分类，并且其有两个标签hexo和next现在进入首页点击分类和标签按钮即可按分类和标签找到该文章给文章配置图片 方法1 1234567在项目根目下创建images文件夹将图片放入该文件夹如果绑定自己的域名则使用md标签应用图片如![按钮](/images/menu.png)注意：如果使用github提供的域名，由于在github中代码是放在仓库的二级目录中，所以路径需该为![按钮](/仓库名/images/menu.png) 方法2(暂未成功)12345678910更改主目录的_config.yml的文件修改以下配置post_asset_folder: true 当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。 这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后， 你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。在md中使用标签&#123;% asset_img menu.png 标题 %&#125;来引入图片 首页展示文章全文的问题 首页中展示的文章是全文，这样导致首页非常的长，可以使用md语法在文章中加入来控制首页展示的长度]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下hexo搭建]]></title>
    <url>%2F2019%2F08%2F29%2Fhexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[下载nodejs nodejs下载地址下载 安装hexo1npm install -g hexo-cli 构建hexo项目 安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ cd &lt;folder&gt;$ npm install 安装nodejs的依赖到hexo目录下$ hexo init &lt;folder&gt; 初始化hexo项目 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml 网站的配置信息,可以在此配置大部分的参数,详细配置参考官网[配置](https://hexo.io/zh-cn/docs/configuration)├── package.json├── scaffolds 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件├── source 资源文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去| ├── _drafts| └── _posts└── themes 主题目录，主题有自己的_config.yml文件，用来配置主题自己的属性 编译开启web服务 123hexo ghexo s访问http://localhost:4000 即可看见项目 构建时遇到的错误 12在执行hexo init &lt;folder&gt; 命令时 出现ERROR Local hexo not found in错误删除hexo目录下的node_modules文件 然后在hexo工程目录下重新执行npm install 安装nodejs依赖]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
