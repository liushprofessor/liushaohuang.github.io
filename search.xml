<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[缓慢维度的设计和处理]]></title>
    <url>%2F2019%2F09%2F02%2F%E7%BC%93%E6%85%A2%E7%BB%B4%E5%BA%A6%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%A4%84%E7%90%86%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>维度</tag>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据仓库维度建模概述]]></title>
    <url>%2F2019%2F08%2F31%2F%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是维度 简单的来说维度就是用于分析数据仓库中的事实的描述（关于事实下文讲解）.举个例子在数据库中有两张表，订单明细表和商品表 订单明细表 ID_ ORDER_ID PRODUCT_ID_ quantity 1 1 1 10 商品表 ID_ PRODUCT_NAME 1 华为手机 这两张表中订单明细表使用商品表中的id与之关联，订单明细表为事实表记录了订单明细的事实，商品表就为维度表，因为商品表描述了订单明细表，我们通过商品表中的维度信息去分析订单明细表中的数据，用需求文字来描述就是我想查购买了华为手机的所有订单明细，转换成SQL语句为 1select * from 订单表 t1 inner join 商品表 t2 on t1.PRODUCT_ID_=t2.ID_ where t2.PRODUCT_NAME=&apos;华为手机&apos; 什么是事实 事实一般只是一些单纯的数字，如上文订单表中的数量，它仅仅是订单中的一个度量，没有什么文字描述，文字描述都存在维度表中,通过维度表去分析事实表。 什么是粒度 事实表中的存储数据都要有相同的粒度,粒度用于确定某一事实表中的行表示什么,例如上文订单明细表中的粒度是到商品,不是订单，因为表中有一个产品id，如果该表去掉PRODUCT_ID_和quantity那么该事实表中的粒度就为订单（一个订单中可能包含很多商品）,所有的事实表中的数据都应该有相同的粒度，同样维度表中的关联也需要和事实表中的粒度做对应，就好比上文的订单明细表中最好不要出现订单的维度，比如订单类型等信息. 设计维度的过程选择业务过程 业务过程一般存储在业务系统的关系型数据库中，我们必须根据需求选取对应业务表中的数据，如我需要建立订单为主题的数据集市，则我需要抽取业务系统中关于订单的数据 声明粒度 最好要包行最低粒度，如上文中建立一张订单明细表，而不是只建立订单表，因为细粒度可以根据维度上卷得到粗粒度的数据，反之则不能。 描述维度 维度提供业务的描述，比如谁，什么，何处，何时等。维度表为数据仓库中的灵魂，是数据仓库中最重要的部分，维度描述越丰富，则数据仓库中所挖掘的信息越多。 确认事实 事实涉及业务过程事件的度量,基本上都是以数量值表示，一个事实表中的所有粒度需要保持一致。 数据仓库的分层 目前项目中采用了4层架构分别为 ods贴源层，ods层中存放了业务表中原封不动的数据 dwd数据清洗层,dwd为了清理ods层中的数据 dws主题层,此层获取dwd中的数据根据不同的主题组成不同粒度的事实表和维度供业务方调用 ads层，此层一般为一些汇总数据供前端展示时调用 不同数据集市间的数据划分可以考虑在同一个数据实例中根据表名建立各个数据集市中的4个不同的层，根据表名区分不同数据集市中的表，也可以根据不同数据集市建立不同的数据库实例来存储上文4个层的表，目前由于建立的数据集市较少为了方便才用同一个数据库实例。 数据的仓库架构总线型架构 Kimball总线架构为，在项目开始时，由架构师设计通用维度，这个维度称为总线，设计完成总线后，将总线维度分发给各个数据集市的开发人员同步去开发，比如订单数据集市，库存数据集市。各个集市中的维度根据总线去做扩展，各个数据集市的数据再ads层之前是不做交互的，如果要跨域多个数据集市去分析数据，那么就用通用维度（总线）去连接各个数据集市中的不同事实表去分析数据。 维度表设计 现在维度表的设计一般分为星型结构和雪花型结构 星型结构，采用宽表和冗余的形式存储维度，维度的父子关系都在一张表中关联，不通过外键关联，如下面时间表: id 年 月 日 20190101 2019 01 01 20190102 2019 01 02 那么如果我想查询实时表中id为20190101的数据对应的月份是几月，那么我们可以使用id去时间维度去查找对应的月份 雪花结构,雪花结构的设计更多的用于关系型数据库，上图的时间维度用雪花型表示为年表 id 年 2019 2019 2018 2018 月表 id 月份 1 01 2 02 年月关系表 id year_id month_id 1 2019 1 2 2019 2 两种设计的优缺星型结构：对查找的效率和难度来说更加高效简单，但是存储了大量冗余数据，而且不够灵活不方便修改，如果存在大量描述字段的话，那么冗余结构相比雪花结构使用更大的存储空间雪花结构：数据更加灵活，比如更改维度表的信息不需要更改整个维度的信息，比如上文我要更改月份里面的字段我只需要更改月表中的信息即可，不需要更改整张维度表，但是查询更加麻烦和慢。其实归根到底就是范式设计和非范式设计，在数仓中大多数情况下应该使用星型结构，因为数仓关注的是查询，用存储空间换取查询数据的方便是值得的，至于对于星型结构存在维度变更的问题，我们将在另一篇文章，维度缓慢变化中说明]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>维度</tag>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hive mysql元数据表单的主从备份]]></title>
    <url>%2F2019%2F08%2F30%2Fhive-mysql%E5%85%83%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%8D%95%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[hive元数据库和使用介绍 hive 会将表的元数据信息存储在数据库中，这里采用mysql作为元数据库存储hive的元数据 元数据表中记录着很多hive中有用的信息，比如数据库实例，表，表结构，还有表数据的条数 表数据条数只有在hive为内部表时的统计是准确的，如果建立的表为外部表 (external)则需要执行统计语句才能得到准确结果 1ANALYZE TABLE tablename COMPUTE STATISTICS; 使用元数据表中的统计数据可以很简单快捷的得到hive的元数据，比如表的数量，和数据量 mysql主从介绍 mysql主从时利用mysql的日志来完成主从的，所以在做主从设置时，先要保证主数据库和从数据库数据的一致 迁移数据 如果主数据库中已经在做主从时已经存在数据那么，先将主数据库中数据复制到从数据库中，从而保证主数据库和从数据库数据的一致 配置主数据库配置文件 1234567891011vi /etc/my.cnf#将以下信息填入server-id = 1 #Mysql服务的唯一编号 每个mysql服务Id需唯一log-bin=mysql-bin #logbin的名字binlog-do-db=metastore #需要同步的数据库的名字，如果是多个数据库存在多条binlog-ignore-db=test01 #不需要同步的数据库的名字log-slave-updates=1 #log更新间隔slave-skip-errors=1 #是跳过错误，继续执行复制操作(可选)binlog_format=MIXED #必须制定日志的类型，这里选择混合日志存储，不然无法建立hive表#重启数据库service mysqld restart 配置从数据配置文件 12345678910#Mysql服务的唯一编号 每个mysql服务Id需唯一server-id = 2read_only=1#只读模式，可以限定普通用户进行数据修改的操作，但不会限定具有super权限的用户（如超级管理员root用户）的数据修改操作。如果想保证super用户也不能写操作，就可以就需要执行给所有的表加读锁的命令 “flush tables with read lock;”replicate-do-db=metastore #需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可replicate-ignore-db=test05 #需要忽略不复制数据库名，如果个数据库，重复设置这个选项即可replicate-rewrite-db = metastore-&gt;apollo # 如果主数据库名字和从数据库名不一样，则使用这个配置，表明将主数据库metastore#复制到从数据库apollo实例下，和replicate-do-db配置不能共存#重启数据库service mysqld restart 设置主数据库复制账号 123456CREATE USER &apos;slave&apos;@&apos;%&apos; IDENTIFIED BY &apos;mysql&apos;;GRANT REPLICATION SLAVE ON *.* TO &apos;slave&apos;@&apos;%&apos;;FLUSH PRIVILEGES;# 查看赋权状态use mysql;select User,authentication_string,Host from user; 查看是否开启日志 1show variables like &apos;log_bin&apos;; 如果开启value值为on Variable_name Value log_bin ON 查看主节点状态1show master status; 结果示例,表示 metastore实例日志文件为mysql-bin.000005，当前日志偏移量为1242284 File Position Binlog_Do_DB mysql-bin.000005 1242284 metastore 操作从数据库 其中change master语句中的master_log_file 为上一步查看的metastore日志文件，master_log_pos为该日志文件的偏移量，这样主数据库中的数据发生变化，偏移量就会增长，从数据库根据偏移量去同步数据 123456# 停止正在进行的slave(如果有，此方法也用于修改slave的值(如果参数不对))stop slave;# 需要主机名，上面步骤的账户密码以及日志文件名字和位置(请根据实际情况自行修改)change master to master_host=&apos;192.168.1.1&apos;, master_user=&apos;slave&apos;, master_password=&apos;mysql&apos;, master_log_file=&apos;mysql-bin.000005&apos;, master_log_pos=1242284;# 启动start slave; 查看状态 12345show slave status;如果发现Slave_IO_Running和Slave_SQL_Running状态为YES则成功Slave_IO_Running负责和主机通讯Slave_SQL_Running负者执行从数据库sql语句Last_Error复制记录上一次同步出错的出错愿意 易错注意点 在配置主数据库配置文件时必须指定 binlog_format类型，不然hive建表会出错 配置从数据配置文件时，replicate-do-db=metastore和replicate-rewrite-db不能共存 当同步主数据库的数据到不同名字的从数据库中时，不可直接用Navicat图形化工具去直接操作数据库，应该写语句去执行，不然会导致同步失败]]></content>
      <categories>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
        <tag>mysql主从搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将hexo发布到github]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%B0%86hexo%E5%8F%91%E5%B8%83%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[创建一个github仓库 创建一个github公有仓库,点击settings如图 选择GitHub Pages选项 设置git分支为，和访问域名 设置hexo部署目录1234567891011打开项目目录下的_config.yml文件修改deploy:属性type 为类型设置为gitbranch设置为master分支repo为你的仓库地址如deploy:type: gitbranch: masterrepo: https:// 参数解释 参数 描述 repo 库（Repository）地址 branch 分支名称。如果不指定，则默认值为 master message 自定义提交信息,非必须 安装部署插件 12进入项目主目录执行$ npm install hexo-deployer-git --save 上传CNAME文件 在项目目录下source中创建一个名字为CNAME的文件，里面填入你所绑定的域名 发布项目至github pages 123$ hexo clean$ hexo g$ hexo d 解决样式丢失问题 此时发布项目至github，css样式会丢失修改以下内容 12345678910打开项目目录下的_config.yml文件修改如下参数url: https://liushprofessor.github.io/liushaohuang.github.io/root: /liushaohuang.github.iopermalink: :year/:month/:day/:title/permalink_defaults:其中url替换为你github的仓库地址(网址)root 为网站的根目录（github对应的仓库名）重新发布解决问题 绑定域名 将域名cname设置为A记录代表ip ，cname代表绑定域名 ,主机记录www代表匹配www.前置网站如www.liushaohuang.cn@ 表示直接解析主域名，匹配liushaohuang.cn的网站 记录类型 主机记录 记录值 A www ip地址 CNAME @ 域名 CNAME WWW 域名]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题的更换]]></title>
    <url>%2F2019%2F08%2F29%2Fhexo%E4%B8%BB%E9%A2%98%E7%9A%84%E6%9B%B4%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[主题主体安装设置 这里以next主题为例，进入hexo项目目录，执行以下命令，从github上下载next主题,并将主题存放在themes目录的next文件夹下 1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 更改主题 12345项目主目录进入主目录，这里以hexo为例$ cd hexo打开该目录下的_config.yml文件将theme属性更改为theme: next 更改主题文字为中文 123同上打开主目录下的_config.yml文件将language属性更改为language: zh-CN 更改主题标题 123同上打开主目录下的_config.yml文件修改title标签为想要的标题title: 标题 主题内部设置 主题内部配置文件为themes/next目录下的_config.yml 更改主题样式 12345在主题配置文件中更改scheme属性来切换不同样式的主题#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 配置菜单找到menu标签以下配置在主要中打开主页，归档页，分类和标签如下图所示 1234567menu: home: / archives: /archives #about: /about categories: /categories tags: /tags #commonweal: /404.html 每个标签的含义为 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 about about: /about 关于页面 commonweal commonweal: /404.html 公益 404 配置标签和分类按钮 现在点击标签和分类按钮是无法使用的，下面进行标签和分类按钮的配置 标签按钮配置 12345678910在hexo项目下执行hexo new page tags执行完成后在source\tags目录下生成index.md文件打开文件在标题中增加 type: &quot;tags&quot;如---title: tagsdate: 2019-08-29 14:35:28type: &quot;tags&quot;--- 配置分类按钮 123456789同上打开工程目录hexo new page categories打开文件在标题中增加 type: &quot;categories&quot;如---title: categoriesdate: 2019-08-29 14:43:25type: &quot;categories&quot;--- 编写博客内容1234567891011121314 执行 hexo new 标题 在source/_posts目录下会出现 标题.md文件 打开文件 给博文添加分类和标签 categories，tags 如下 --- title: 标题 date: 2019-08-29 13:45:29 categories: hexo tags: -hexo -next ---这样这个博文就属于hexo分类，并且其有两个标签hexo和next现在进入首页点击分类和标签按钮即可按分类和标签找到该文章给文章配置图片 方法1 1234567在项目根目下创建images文件夹将图片放入该文件夹如果绑定自己的域名则使用md标签应用图片如![按钮](/images/menu.png)注意：如果使用github提供的域名，由于在github中代码是放在仓库的二级目录中，所以路径需该为![按钮](/仓库名/images/menu.png) 方法2(暂未成功)12345678910更改主目录的_config.yml的文件修改以下配置post_asset_folder: true 当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。 这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后， 你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。在md中使用标签&#123;% asset_img menu.png 标题 %&#125;来引入图片 首页展示文章全文的问题 首页中展示的文章是全文，这样导致首页非常的长，可以使用md语法在文章中加入来控制首页展示的长度]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下hexo搭建]]></title>
    <url>%2F2019%2F08%2F29%2Fhexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[下载nodejs nodejs下载地址下载 安装hexo1npm install -g hexo-cli 构建hexo项目 安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ cd &lt;folder&gt;$ npm install 安装nodejs的依赖到hexo目录下$ hexo init &lt;folder&gt; 初始化hexo项目 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml 网站的配置信息,可以在此配置大部分的参数,详细配置参考官网[配置](https://hexo.io/zh-cn/docs/configuration)├── package.json├── scaffolds 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件├── source 资源文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去| ├── _drafts| └── _posts└── themes 主题目录，主题有自己的_config.yml文件，用来配置主题自己的属性 编译开启web服务 123hexo ghexo s访问http://localhost:4000 即可看见项目 构建时遇到的错误 12在执行hexo init &lt;folder&gt; 命令时 出现ERROR Local hexo not found in错误删除hexo目录下的node_modules文件 然后在hexo工程目录下重新执行npm install 安装nodejs依赖]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
